<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Adding meta -->
    

    <!-- Adding external script-->
    

    <!-- Adding external style-->
    

    <!-- Adding scripts-->
    

    <!-- Adding style-->
    
    
    

    <!-- Adding overlay script-->
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/overlayscrollbars/1.13.0/js/OverlayScrollbars.min.js"
      integrity="sha512-5R3ngaUdvyhXkQkIqTf/k+Noq3phjmrqlUQyQYbgfI34Mzcx7vLIIYTy/K1VMHkL33T709kfh5y6R9Xy/Cbt7Q=="
      crossorigin="anonymous"></script>
    

    <!-- Adding overlay style-->
    
    <link rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/overlayscrollbars/1.13.0/css/OverlayScrollbars.min.css"
      integrity="sha512-pYQcc5kgavar0ah58/O8hw/6Tbo3mWlmQTmvoi1i96cBz7jQYS9as5J+Nfy32rAHY6CgR9ExwnFMcBdGVcKM7g=="
      crossorigin="anonymous" />
    


    <title>
      index.js
    </title>

    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/third-party/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/third-party/prism.css">
    <link type="text/css" rel="stylesheet" href="styles/reset.css">
    <link type="text/css" rel="stylesheet" href="styles/clean-jsdoc-theme-base.css">
    <link type="text/css" rel="stylesheet" href="styles/clean-jsdoc-theme-dark.css">
    
    <svg aria-hidden="true" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
    style="display:none">
    <defs>
        <symbol id="copy-icon" viewbox="0 0 488.3 488.3">
            <g>
                <path
                    d="M314.25,85.4h-227c-21.3,0-38.6,17.3-38.6,38.6v325.7c0,21.3,17.3,38.6,38.6,38.6h227c21.3,0,38.6-17.3,38.6-38.6V124    C352.75,102.7,335.45,85.4,314.25,85.4z M325.75,449.6c0,6.4-5.2,11.6-11.6,11.6h-227c-6.4,0-11.6-5.2-11.6-11.6V124    c0-6.4,5.2-11.6,11.6-11.6h227c6.4,0,11.6,5.2,11.6,11.6V449.6z" />
                <path
                    d="M401.05,0h-227c-21.3,0-38.6,17.3-38.6,38.6c0,7.5,6,13.5,13.5,13.5s13.5-6,13.5-13.5c0-6.4,5.2-11.6,11.6-11.6h227    c6.4,0,11.6,5.2,11.6,11.6v325.7c0,6.4-5.2,11.6-11.6,11.6c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5c21.3,0,38.6-17.3,38.6-38.6    V38.6C439.65,17.3,422.35,0,401.05,0z" />
            </g>
        </symbol>
        <symbol id='search-icon' viewBox="0 0 512 512">
            <g>
                <g>
                    <path
                        d="M225.474,0C101.151,0,0,101.151,0,225.474c0,124.33,101.151,225.474,225.474,225.474    c124.33,0,225.474-101.144,225.474-225.474C450.948,101.151,349.804,0,225.474,0z M225.474,409.323    c-101.373,0-183.848-82.475-183.848-183.848S124.101,41.626,225.474,41.626s183.848,82.475,183.848,183.848    S326.847,409.323,225.474,409.323z" />
                </g>
            </g>
            <g>
                <g>
                    <path
                        d="M505.902,476.472L386.574,357.144c-8.131-8.131-21.299-8.131-29.43,0c-8.131,8.124-8.131,21.306,0,29.43l119.328,119.328    c4.065,4.065,9.387,6.098,14.715,6.098c5.321,0,10.649-2.033,14.715-6.098C514.033,497.778,514.033,484.596,505.902,476.472z" />
                </g>
            </g>
        </symbol>
        <symbol id="down-icon" viewBox="0 0 16 16">
            <path 
                fill-rule="evenodd" 
                clip-rule="evenodd" 
                d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z"
            >
            </path>
        </symbol>

        <symbol id="brush-icon" viewBox="0 0 24 24">
            <path d="M0 0h24v24H0z" fill="none"/>
            <path d="M7 14c-1.66 0-3 1.34-3 3 0 1.31-1.16 2-2 2 .92 1.22 2.49 2 4 2 2.21 0 4-1.79 4-4 0-1.66-1.34-3-3-3zm13.71-9.37l-1.34-1.34c-.39-.39-1.02-.39-1.41 0L9 12.25 11.75 15l8.96-8.96c.39-.39.39-1.02 0-1.41z"/>
        </symbol>
    </defs>
</svg>
  </head>

  <body class="line-numbers">

    <nav class="navbar" id="navbar">
      <div class="navbar-heading" id="navbar-heading"><a href="index.html"><h2 class="navbar-heading-text">jLight Docs</h2></a></div><div class="search-box" id="search-box"><div class="search-box-input-container"><input class="search-box-input" type="text" placeholder="Search..." id="search-box-input" /><svg class="search-icon" alt="search-icon"><use xlink:href="#search-icon"></use></svg></div><div class="search-item-container" id="search-item-container"><ul class="search-item-ul" id="search-item-ul"></ul></div></div><div class="sidebar-main-content" id="sidebar-main-content"><div class="accordion collapsed" id="1163754789" > <h3 class="accordion-heading">Modules<svg><use xlink:href="#down-icon"></use></svg></h3><ul class="accordion-content"><li class="accordion collapsed child" id=187684621><div class="accordion-heading child"><a href="module-Ajax.html">Ajax</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="module-Ajax.html#.ajax">ajax</a></li><li data-type='method'><a href="module-Ajax.html#.get">get</a></li><li data-type='method'><a href="module-Ajax.html#.post">post</a></li></ul></li><li class="accordion collapsed child" id=290529412><div class="accordion-heading child"><a href="module-Animation.html">Animation</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="module-Animation.html#~animate">animate</a></li><li data-type='method'><a href="module-Animation.html#~fadeIn">fadeIn</a></li><li data-type='method'><a href="module-Animation.html#~fadeOut">fadeOut</a></li><li data-type='method'><a href="module-Animation.html#~fadeToggle">fadeToggle</a></li><li data-type='method'><a href="module-Animation.html#~scrollTo">scrollTo</a></li><li data-type='method'><a href="module-Animation.html#~slideDown">slideDown</a></li><li data-type='method'><a href="module-Animation.html#~slideToggle">slideToggle</a></li><li data-type='method'><a href="module-Animation.html#~slideUp">slideUp</a></li><li data-type='method'><a href="module-Animation.html#~stop">stop</a></li></ul></li><li class="accordion collapsed child" id=511264997><div class="accordion-heading child"><a href="module-ArrayLike.html">ArrayLike</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="module-ArrayLike.html#~concat">concat</a></li><li data-type='method'><a href="module-ArrayLike.html#~each">each</a></li><li data-type='method'><a href="module-ArrayLike.html#~every">every</a></li><li data-type='method'><a href="module-ArrayLike.html#~filter">filter</a></li><li data-type='method'><a href="module-ArrayLike.html#~find">find</a></li><li data-type='method'><a href="module-ArrayLike.html#~forEach">forEach</a></li><li data-type='method'><a href="module-ArrayLike.html#~includes">includes</a></li><li data-type='method'><a href="module-ArrayLike.html#~indexOf">indexOf</a></li><li data-type='method'><a href="module-ArrayLike.html#~lastIndexOf">lastIndexOf</a></li><li data-type='method'><a href="module-ArrayLike.html#~map">map</a></li><li data-type='method'><a href="module-ArrayLike.html#~pop">pop</a></li><li data-type='method'><a href="module-ArrayLike.html#~push">push</a></li><li data-type='method'><a href="module-ArrayLike.html#~reduce">reduce</a></li><li data-type='method'><a href="module-ArrayLike.html#~reverse">reverse</a></li><li data-type='method'><a href="module-ArrayLike.html#~shift">shift</a></li><li data-type='method'><a href="module-ArrayLike.html#~slice">slice</a></li><li data-type='method'><a href="module-ArrayLike.html#~some">some</a></li><li data-type='method'><a href="module-ArrayLike.html#~sort">sort</a></li><li data-type='method'><a href="module-ArrayLike.html#~splice">splice</a></li><li data-type='method'><a href="module-ArrayLike.html#~unshift">unshift</a></li></ul></li><li class="accordion collapsed child" id=1257292249><div class="accordion-heading child"><a href="module-CSS.html">CSS</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="module-CSS.html#~addClass">addClass</a></li><li data-type='method'><a href="module-CSS.html#~css">css</a></li><li data-type='method'><a href="module-CSS.html#~hasClass">hasClass</a></li><li data-type='method'><a href="module-CSS.html#~hide">hide</a></li><li data-type='method'><a href="module-CSS.html#~removeClass">removeClass</a></li><li data-type='method'><a href="module-CSS.html#~show">show</a></li><li data-type='method'><a href="module-CSS.html#~toggle">toggle</a></li><li data-type='method'><a href="module-CSS.html#~toggleClass">toggleClass</a></li></ul></li><li class="accordion collapsed child" id=555768678><div class="accordion-heading child"><a href="module-Dimensions.html">Dimensions</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="module-Dimensions.html#~height">height</a></li><li data-type='method'><a href="module-Dimensions.html#~innerHeight">innerHeight</a></li><li data-type='method'><a href="module-Dimensions.html#~innerWidth">innerWidth</a></li><li data-type='method'><a href="module-Dimensions.html#~offset">offset</a></li><li data-type='method'><a href="module-Dimensions.html#~outerHeight">outerHeight</a></li><li data-type='method'><a href="module-Dimensions.html#~outerWidth">outerWidth</a></li><li data-type='method'><a href="module-Dimensions.html#~scrollHeight">scrollHeight</a></li><li data-type='method'><a href="module-Dimensions.html#~scrollLeft">scrollLeft</a></li><li data-type='method'><a href="module-Dimensions.html#~scrollTop">scrollTop</a></li><li data-type='method'><a href="module-Dimensions.html#~scrollWidth">scrollWidth</a></li><li data-type='method'><a href="module-Dimensions.html#~width">width</a></li></ul></li><li class="accordion collapsed child" id=183346920><div class="accordion-heading child"><a href="module-ElementData.html">ElementData</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="module-ElementData.html#~attr">attr</a></li><li data-type='method'><a href="module-ElementData.html#~data">data</a></li><li data-type='method'><a href="module-ElementData.html#~html">html</a></li><li data-type='method'><a href="module-ElementData.html#~prop">prop</a></li><li data-type='method'><a href="module-ElementData.html#~removeAttr">removeAttr</a></li><li data-type='method'><a href="module-ElementData.html#~text">text</a></li><li data-type='method'><a href="module-ElementData.html#~val">val</a></li></ul></li><li class="accordion collapsed child" id=1946157975><div class="accordion-heading child"><a href="module-Event.html">Event</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="module-Event.html#~delegate">delegate</a></li><li data-type='method'><a href="module-Event.html#~off">off</a></li><li data-type='method'><a href="module-Event.html#~on">on</a></li><li data-type='method'><a href="module-Event.html#~once">once</a></li><li data-type='method'><a href="module-Event.html#~trigger">trigger</a></li><li data-type='method'><a href="module-Event.html#~undelegate">undelegate</a></li></ul></li><li class="accordion collapsed child" id=73280681><div class="accordion-heading child"><a href="module-Manipulation.html">Manipulation</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="module-Manipulation.html#~add">add</a></li><li data-type='method'><a href="module-Manipulation.html#~after">after</a></li><li data-type='method'><a href="module-Manipulation.html#~append">append</a></li><li data-type='method'><a href="module-Manipulation.html#~appendTo">appendTo</a></li><li data-type='method'><a href="module-Manipulation.html#~before">before</a></li><li data-type='method'><a href="module-Manipulation.html#~clone">clone</a></li><li data-type='method'><a href="module-Manipulation.html#~empty">empty</a></li><li data-type='method'><a href="module-Manipulation.html#~insertAfter">insertAfter</a></li><li data-type='method'><a href="module-Manipulation.html#~insertBefore">insertBefore</a></li><li data-type='method'><a href="module-Manipulation.html#~prepend">prepend</a></li><li data-type='method'><a href="module-Manipulation.html#~prependTo">prependTo</a></li><li data-type='method'><a href="module-Manipulation.html#~remove">remove</a></li><li data-type='method'><a href="module-Manipulation.html#~wrap">wrap</a></li></ul></li><li class="accordion-list" id=414932317><a href="module-Properties.html">Properties</a></li><li class="accordion collapsed child" id=1577478690><div class="accordion-heading child"><a href="module-Selection.html">Selection</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="module-Selection.html#~children">children</a></li><li data-type='method'><a href="module-Selection.html#~closest">closest</a></li><li data-type='method'><a href="module-Selection.html#~eq">eq</a></li><li data-type='method'><a href="module-Selection.html#~first">first</a></li><li data-type='method'><a href="module-Selection.html#~get">get</a></li><li data-type='method'><a href="module-Selection.html#~has">has</a></li><li data-type='method'><a href="module-Selection.html#~last">last</a></li><li data-type='method'><a href="module-Selection.html#~next">next</a></li><li data-type='method'><a href="module-Selection.html#~not">not</a></li><li data-type='method'><a href="module-Selection.html#~parent">parent</a></li><li data-type='method'><a href="module-Selection.html#~parents">parents</a></li><li data-type='method'><a href="module-Selection.html#~prev">prev</a></li><li data-type='method'><a href="module-Selection.html#~siblings">siblings</a></li></ul></li><li class="accordion collapsed child" id=910181038><div class="accordion-heading child"><a href="module-String.html">String</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="module-String.html#.camelToKebab">camelToKebab</a></li><li data-type='method'><a href="module-String.html#.camelToSnake">camelToSnake</a></li><li data-type='method'><a href="module-String.html#.kebabToCamel">kebabToCamel</a></li><li data-type='method'><a href="module-String.html#.kebabToSnake">kebabToSnake</a></li><li data-type='method'><a href="module-String.html#.lcfirst">lcfirst</a></li><li data-type='method'><a href="module-String.html#.snakeToCamel">snakeToCamel</a></li><li data-type='method'><a href="module-String.html#.snakeToKebab">snakeToKebab</a></li><li data-type='method'><a href="module-String.html#.ucfirst">ucfirst</a></li></ul></li><li class="accordion collapsed child" id=1201969004><div class="accordion-heading child"><a href="module-Utility.html">Utility</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="module-Utility.html#.doEasing">doEasing</a></li><li data-type='method'><a href="module-Utility.html#.generateHash">generateHash</a></li><li data-type='method'><a href="module-Utility.html#.isEmptyObject">isEmptyObject</a></li><li data-type='method'><a href="module-Utility.html#.isSameObject">isSameObject</a></li><li data-type='method'><a href="module-Utility.html#.noop">noop</a></li><li data-type='method'><a href="module-Utility.html#.preventEvent">preventEvent</a></li><li data-type='method'><a href="module-Utility.html#.uniqid">uniqid</a></li><li data-type='method'><a href="module-Utility.html#~contains">contains</a></li><li data-type='method'><a href="module-Utility.html#~delay">delay</a></li><li data-type='method'><a href="module-Utility.html#~inView">inView</a></li><li data-type='method'><a href="module-Utility.html#~is">is</a></li><li data-type='method'><a href="module-Utility.html#~serialize">serialize</a></li><li data-type='method'><a href="module-Utility.html#~serializeJson">serializeJson</a></li><li data-type='method'><a href="module-Utility.html#~when">when</a></li></ul></li></ul> </div><div class="accordion collapsed" id="1163754789" > <h3 class="accordion-heading">Tutorials<svg><use xlink:href="#down-icon"></use></svg></h3><ul class="accordion-content"><li class="accordion-list" id=187684621><a href="tutorial-tut-ajax.html">Ajax</a></li><li class="accordion-list" id=290529412><a href="tutorial-tut-animation.html">Animation</a></li><li class="accordion-list" id=511264997><a href="tutorial-tut-array-like.html">ArrayLike</a></li><li class="accordion-list" id=constructor-tutorial><a href="tutorial-tut-constructor.html">Constructor</a></li><li class="accordion-list" id=555768678><a href="tutorial-tut-css.html">CSS</a></li><li class="accordion-list" id=183346920><a href="tutorial-tut-dimensions.html">Dimensions</a></li><li class="accordion-list" id=1946157975><a href="tutorial-tut-element-data.html">ElementData</a></li><li class="accordion-list" id=73280681><a href="tutorial-tut-event.html">Event</a></li><li class="accordion-list" id=414932317><a href="tutorial-tut-manipulation.html">Manipulation</a></li><li class="accordion-list" id=1577478690><a href="tutorial-tut-properties.html">Properties</a></li><li class="accordion-list" id=910181038><a href="tutorial-tut-selection.html">Selection</a></li><li class="accordion-list" id=1201969004><a href="tutorial-tut-string.html">String</a></li><li class="accordion-list" id=591529950><a href="tutorial-tut-utility.html">Utility</a></li></ul> </div><div class="accordion collapsed" id="1163754789" > <h3 class="accordion-heading">Global<svg><use xlink:href="#down-icon"></use></svg></h3><ul class="accordion-content"><li class="accordion-list" id=187684621><a href="global.html#$">$</a></li><li class="accordion-list" id=290529412><a href="global.html#ajaxCompleteCallback">ajaxCompleteCallback</a></li><li class="accordion-list" id=511264997><a href="global.html#animateCallback">animateCallback</a></li><li class="accordion-list" id=1257292249><a href="global.html#animateOutCallback">animateOutCallback</a></li><li class="accordion-list" id=555768678><a href="global.html#arrayBooleanCallback">arrayBooleanCallback</a></li><li class="accordion-list" id=183346920><a href="global.html#arrayLengthCallback">arrayLengthCallback</a></li><li class="accordion-list" id=1946157975><a href="global.html#attrCallback">attrCallback</a></li><li class="accordion-list" id=73280681><a href="global.html#cloneCallback">cloneCallback</a></li><li class="accordion-list" id=414932317><a href="global.html#compareCallback">compareCallback</a></li><li class="accordion-list" id=1577478690><a href="global.html#contentCallback">contentCallback</a></li><li class="accordion-list" id=910181038><a href="global.html#cssCallback">cssCallback</a></li><li class="accordion-list" id=1201969004><a href="global.html#cssClassCallback">cssClassCallback</a></li><li class="accordion-list" id=591529950><a href="global.html#dataCallback">dataCallback</a></li><li class="accordion-list" id=1321930081><a href="global.html#defaultCallback">defaultCallback</a></li><li class="accordion-list" id=1263008729><a href="global.html#delayCallback">delayCallback</a></li><li class="accordion-list" id=480839917><a href="global.html#delegateCallback">delegateCallback</a></li><li class="accordion-list" id=1534823849><a href="global.html#dimensionCallback">dimensionCallback</a></li><li class="accordion-list" id=1877423431><a href="global.html#elementsBooleanCallback">elementsBooleanCallback</a></li><li class="accordion-list" id=868714842><a href="global.html#elementsCallback">elementsCallback</a></li><li class="accordion-list" id=1235699803><a href="global.html#elementsNumberCallback">elementsNumberCallback</a></li><li class="accordion-list" id=210634841><a href="global.html#eventCallback">eventCallback</a></li><li class="accordion-list" id=1731505896><a href="global.html#fadeCallback">fadeCallback</a></li><li class="accordion-list" id=72807782><a href="global.html#fadeToggleCallback">fadeToggleCallback</a></li><li class="accordion-list" id=735468482><a href="global.html#filterCallback">filterCallback</a></li><li class="accordion-list" id=1390759775><a href="global.html#getOrSetValueCallback">getOrSetValueCallback</a></li><li class="accordion-list" id=30024345><a href="global.html#hasClassCallback">hasClassCallback</a></li><li class="accordion-list" id=1708314287><a href="global.html#indexElementCallback">indexElementCallback</a></li><li class="accordion-list" id=1565982135><a href="global.html#indexjLightCallback">indexjLightCallback</a></li><li class="accordion-list" id=2011356424><a href="global.html#inViewCallback">inViewCallback</a></li><li class="accordion-list" id=1440384724><a href="global.html#isCallback">isCallback</a></li><li class="accordion-list" id=1244242072><a href="global.html#iteratorBooleanCallback">iteratorBooleanCallback</a></li><li class="accordion-list" id=1805155348><a href="global.html#iteratorCallback">iteratorCallback</a></li><li class="accordion-list" id=732163506><a href="global.html#jLight">jLight</a></li><li class="accordion-list" id=216717108><a href="global.html#mapCallback">mapCallback</a></li><li class="accordion-list" id=1835977340><a href="global.html#mapInnerCallback">mapInnerCallback</a></li><li class="accordion-list" id=1925265516><a href="global.html#multipleElementsCallback">multipleElementsCallback</a></li><li class="accordion-list" id=1481513262><a href="global.html#offCallback">offCallback</a></li><li class="accordion-list" id=1365561152><a href="global.html#offsetCallback">offsetCallback</a></li><li class="accordion-list" id=1730244076><a href="global.html#onCallback">onCallback</a></li><li class="accordion-list" id=1155352663><a href="global.html#onStepCallback">onStepCallback</a></li><li class="accordion-list" id=1412972542><a href="global.html#outerDimensionCallback">outerDimensionCallback</a></li><li class="accordion-list" id=491854083><a href="global.html#outerIteratorCallback">outerIteratorCallback</a></li><li class="accordion-list" id=1827311689><a href="global.html#propCallback">propCallback</a></li><li class="accordion-list" id=1442427067><a href="global.html#reduceCallback">reduceCallback</a></li><li class="accordion-list" id=53539351><a href="global.html#reduceInnerCallback">reduceInnerCallback</a></li><li class="accordion-list" id=617949629><a href="global.html#removeAttrCallback">removeAttrCallback</a></li><li class="accordion-list" id=1835867978><a href="global.html#removeCallback">removeCallback</a></li><li class="accordion-list" id=2111701452><a href="global.html#scrollToCallback">scrollToCallback</a></li><li class="accordion-list" id=1885075797><a href="global.html#selectorCallback">selectorCallback</a></li><li class="accordion-list" id=52482272><a href="global.html#sliceCallback">sliceCallback</a></li><li class="accordion-list" id=1880821716><a href="global.html#slideCallback">slideCallback</a></li><li class="accordion-list" id=1204939522><a href="global.html#slideToggleCallback">slideToggleCallback</a></li><li class="accordion-list" id=170881813><a href="global.html#sortCallback">sortCallback</a></li><li class="accordion-list" id=1046235521><a href="global.html#spliceCallback">spliceCallback</a></li><li class="accordion-list" id=913902541><a href="global.html#stringCallback">stringCallback</a></li><li class="accordion-list" id=1603129671><a href="global.html#stringObjectCallback">stringObjectCallback</a></li><li class="accordion-list" id=2089535668><a href="global.html#toggleCssClassCallback">toggleCssClassCallback</a></li><li class="accordion-list" id=2102109409><a href="global.html#toggleVisibilityCallback">toggleVisibilityCallback</a></li><li class="accordion-list" id=893585337><a href="global.html#triggerCallback">triggerCallback</a></li><li class="accordion-list" id=728002324><a href="global.html#valCallback">valCallback</a></li><li class="accordion-list" id=1264711503><a href="global.html#visibilityCallback">visibilityCallback</a></li><li class="accordion-list" id=912672796><a href="global.html#whenCallback">whenCallback</a></li><li class="accordion-list" id=282441273><a href="global.html#xhrCallback">xhrCallback</a></li></ul> </div><h3 class="external-links">External links</h3><ul><li class="menu-li"><a href='https://github.com/Brainshaker95/jlight' class=' menu-link' id='' target='_blank'>GitHub</a></li><li class="menu-li"><a href='https://github.com/Brainshaker95/jlightbox' class=' menu-link' id='' target='_blank'>jLightbox</a></li></ul><small class="version">Version: 1.1.1</small></div>
      

    </nav>
    <div class="navbar-ham" id="navbar-ham">
      <div>
        <div class="first"></div>
        <div class="second"></div>
        <div class="third"></div>
      </div>
    </div>

    <div id="main" class="main-content">
      
      <h1 id='page-title' class="page-title">
        index.js
      </h1>
      

      



    
    <section>
        <article>
            <pre class="source language-js"><code class="match-braces">/* eslint-disable jsdoc/check-types */
/* eslint-disable jsdoc/tag-lines */

/**
 * @typedef {Object} jLight
 *
 * @property {HTMLElement[]} elements
 * The collections elements.
 *
 * @property {number} length
 * The collections element count.
 *
 * @property {string} tagName
 * The collections first elements tag name.
 *
 * @property {cssClassCallback} addClass
 * Adds css classes to the collections elements.
 *
 * @property {cssClassCallback} removeClass
 * Removes css classes to the collections elements.
 *
 * @property {toggleCssClassCallback} toggleClass
 * Toggles css classes of the collections elements.
 *
 * @property {hasClassCallback} hasClass
 * Whether at least one of the collections elements has all of the provided classes.
 *
 * @property {cssCallback} css
 * Applies style rules to the collections elements, gets the current style rules
 * or gets the current value for a specific style property.
 *
 * @property {visibilityCallback} show
 * Shows the collections elements.
 *
 * @property {defaultCallback} hide
 * Hides the collections elements.
 *
 * @property {toggleVisibilityCallback} toggle
 * Toggles the collections elements visibility.
 *
 * @property {onCallback} on
 * Adds event handlers to elements.
 *
 * @property {onCallback} once
 * Adds event handlers to elements fo one time execution.
 *
 * @property {offCallback} off
 * Removes event handlers from elements.
 *
 * @property {delegateCallback} delegate
 * [DEPRECATED] Delegates event handlers to elements.
 *
 * @property {delegateCallback} undelegate
 * [DEPRECATED] Undelegates event handlers from elements.
 *
 * @property {triggerCallback} trigger
 * Triggers events on the collections elements.
 *
 * @property {propCallback} prop
 * Sets a property of the collections elements or gets its value.
 *
 * @property {attrCallback} attr
 * Sets an attribute or attributes to the collections elements or gets its value or values.
 *
 * @property {removeAttrCallback} removeAttr
 * Removes the supplied attributes from the collections elements.
 *
 * @property {contentCallback} text
 * Gets or sets the text content of the collections elements.
 *
 * @property {contentCallback} html
 * Gets or sets the HTML content of the collections elements.
 *
 * @property {valCallback} val
 * Gets or sets the collections elements values.
 *
 * @property {dataCallback} data
 * Gets or sets the jLight data of the collections elements.
 *
 * @property {defaultCallback} empty
 * Empties the collections elements HTML content.
 *
 * @property {cloneCallback} clone
 * Clones the collection.
 *
 * @property {elementsCallback} add
 * Adds elements to the collection.
 *
 * @property {removeCallback} remove
 * Removes elements from the collection.
 *
 * @property {elementsCallback} prepend
 * Prepends elements to the collections elements.
 *
 * @property {elementsCallback} append
 * Appends elements to the collections elements.
 *
 * @property {elementsCallback} prependTo
 * Prepends the collections elements to elements.
 *
 * @property {elementsCallback} appendTo
 * Appends the collections elements to elements.
 *
 * @property {elementsCallback} insertBefore
 * Inserts the collections elements before elements.
 *
 * @property {elementsCallback} insertAfter
 * Inserts the collections elements after elements.
 *
 * @property {elementsCallback} before
 * Inserts elements before the collections elements.
 *
 * @property {elementsCallback} after
 * Inserts elements after the collections elements.
 *
 * @property {elementsCallback} wrap
 * Wraps the collections elements in elements.
 *
 * @property {indexElementCallback} get
 * Gets the element at the supplied index from the collection.
 *
 * @property {indexjLightCallback} eq
 * Gets the jLight element at the supplied index from the collection.
 *
 * @property {defaultCallback} first
 * Gets the first jLight element from the collection.
 *
 * @property {defaultCallback} last
 * Gets the last jLight element from the collection.
 *
 * @property {defaultCallback} parent
 * Gets a jLight collection from the collections parent elements.
 *
 * @property {defaultCallback} parents
 * Gets a jLight collection from all the collections parent elements.
 *
 * @property {defaultCallback} children
 * Gets a jLight collection from the collections children elements.
 *
 * @property {defaultCallback} siblings
 * Gets a jLight collection from the collections sibling elements.
 *
 * @property {selectorCallback} prev
 * Gets a jLight collection from the collections previous sibling elements.
 *
 * @property {selectorCallback} next
 * Gets a jLight collection from the collections next sibling elements.
 *
 * @property {selectorCallback} closest
 * Gets a jLight collection from all the collections parent elements matching the selector.
 *
 * @property {elementsCallback} not
 * Gets a jLight collection from the collections elements which are not part of elements.
 *
 * @property {elementsCallback} has
 * Gets a jLight collection from the collections elements which contain elements.
 *
 * @property {filterCallback} filter
 * Gets a filtered jLight collection based on the input.
 *
 * @property {outerIteratorCallback} forEach
 * Runs a function on each of the collections elements.
 *
 * @property {outerIteratorCallback} each
 * [DEPRECATED] Runs a function on each of the collections elements.
 *
 * @property {sliceCallback} slice
 * Slices the collection.
 *
 * @property {spliceCallback} splice
 * Splices the collection.
 *
 * @property {arrayLengthCallback} push
 * Pushes elements to the collection.
 *
 * @property {defaultCallback} pop
 * Pops the last element from the collection.
 *
 * @property {defaultCallback} reverse
 * Reverses a collection.
 *
 * @property {defaultCallback} shift
 * Shifts a collection.
 *
 * @property {arrayLengthCallback} unshift
 * Unshifts a collection.
 *
 * @property {sortCallback} sort
 * Sorts a collection.
 *
 * @property {reduceCallback} reduce
 * Reduces a collection.
 *
 * @property {mapCallback} map
 * Maps a collection.
 *
 * @property {multipleElementsCallback} concat
 * Concats a collection with other collections.
 *
 * @property {elementsBooleanCallback} includes
 * Whether the collections elements include at least one of elements.
 *
 * @property {arrayBooleanCallback} some
 * Whether at least one of the collections elements meets the conditon.
 *
 * @property {arrayBooleanCallback} every
 * Whether every one of the collections elements meets the conditon.
 *
 * @property {elementsNumberCallback} indexOf
 * Gets the given elements index inside the collection.
 *
 * @property {elementsNumberCallback} lastIndexOf
 * Gets the given elements last index inside the collection.
 *
 * @property {selectorCallback} find
 * Gets a jLight collection from the collections children elements matching the selector.
 *
 * @property {getOrSetValueCallback} width
 * Gets or sets the width of the collections elements.
 *
 * @property {getOrSetValueCallback} height
 * Gets or sets the height of the collections elements.
 *
 * @property {dimensionCallback} innerWidth
 * Gets the inner width of the collections elements.
 *
 * @property {dimensionCallback} innerHeight
 * Gets the inner height of the collections elements.
 *
 * @property {outerDimensionCallback} outerWidth
 * Gets the outer width of the collections elements.
 *
 * @property {outerDimensionCallback} outerHeight
 * Gets the outer height of the collections elements.
 *
 * @property {dimensionCallback} scrollWidth
 * Gets the scroll width of the collections elements.
 *
 * @property {dimensionCallback} scrollHeight
 * Gets the scroll height of the collections elements.
 *
 * @property {getOrSetValueCallback} scrollTop
 * Gets or sets the scrollTop of the collections elements.
 *
 * @property {getOrSetValueCallback} scrollLeft
 * Gets or sets the scrollLeft of the collections elements.
 *
 * @property {offsetCallback} offset
 * Gets or sets the collections elements offset.
 *
 * @property {animateCallback} animate
 * Animates the given properties to the given values on the collections elements.
 *
 * @property {scrollToCallback} scrollTo
 * Scrolls the collections elements to elements.
 *
 * @property {defaultCallback} stop
 * Stops all running animations on the collections elements.
 *
 * @property {fadeCallback} fadeIn
 * Fades the collections elements in.
 *
 * @property {animateOutCallback} fadeOut
 * Fades the collections elements out.
 *
 * @property {fadeToggleCallback} fadeToggle
 * Toggles the display state of the collections elements by fading.
 *
 * @property {slideCallback} slideDown
 * Slides the collections elements down.
 *
 * @property {animateOutCallback} slideUp
 * Slides the collections elements up.
 *
 * @property {slideToggleCallback} slideToggle
 * Toggles the display state of the collections elements by sliding.
 *
 * @property {isCallback} is
 * Whether a property of an element of the collection is true
 * or if an element of the collection is part of another set.
 *
 * @property {elementsBooleanCallback} contains
 * Whether the collections elements contain at least one of elements.
 *
 * @property {inViewCallback} inView
 * Checks if the collections first element is in view or runs a function if that is the case.
 *
 * @property {delayCallback} delay
 * Delays code execution.
 *
 * @property {whenCallback} when
 * Calls the supplied function with the supplied arguments if the given condition is met.
 *
 * @property {stringCallback} serialize
 * Serializes the collections elements values to a URL encoded string.
 *
 * @property {stringObjectCallback} serializeJson
 * Serializes the collections elements values to a JSON object.
 */

/* eslint-enable jsdoc/tag-lines */

/**
 * @callback defaultCallback
 * @returns {jLight} jLight collection
 */

/**
 * @callback ajaxCompleteCallback
 * @param {*} [response] The requests response
 * @param {number} [status] The requests HTTP status code
 * @param {XMLHttpRequest} [request] The orginal XMLHttpRequest object
 * @returns {void} void
 */

/**
 * @callback xhrCallback
 * @param {XMLHttpRequest} [request] The orginal XMLHttpRequest object
 * @returns {XMLHttpRequest} XMLHttpRequest
 */

/**
 * @callback onStepCallback
 * @param {number} percent The eased percentage of the current time over the duration
 * @returns {void} void
 */

/**
 * @callback cssClassCallback
 * @param {string} cssClasses Space sepearated classes to supply to the function
 * @returns {jLight} jLight collection
 */

/**
 * @callback toggleCssClassCallback
 * @param {string} cssClasses Space sepearated classes to supply to the function
 * @param {boolean} [force] Force whether to add or remove classes
 * @returns {jLight} jLight collection
 */

/**
 * @callback hasClassCallback
 * @param {string} cssClasses Space sepearated classes to supply to the function
 * @returns {boolean}
 * Whether at least one of the collections elements has all of the provided classes
 */

/**
 * @callback cssCallback
 * @param {string|Object.&lt;string, string>} [property] The property name or the properties to set
 * @param {string} [value] The value to set the supplied property to
 * @returns {jLight|string|CSSStyleDeclaration}
 * jLight collection, property value or elements CSSStyleDeclaration
 */

/**
 * @callback visibilityCallback
 * @param {string} [type] The css display type to apply to the function
 * @returns {jLight} jLight collection
 */

/**
 * @callback toggleVisibilityCallback
 * @param {string} [type] The css display type to apply to the function
 * @param {boolean} [force] Force whether to show or hide elements
 * @returns {jLight} jLight collection
 */

/**
 * @callback eventCallback
 * @param {Event} [event] The dispatched event with jLight elements for the events
 * currentTarget and target attached (event.$currentTarget and event.$target)
 */

/* eslint-disable max-len */

/**
 * @callback onCallback
 * @param {string} eventNames Space separated list of event names
 * @param {eventCallback} callbackOrSelector The function to execute when the event occurs
 * or a selector to delegate events to children of the current collections elements
 * @param {eventCallback|
 *   {capture: boolean, once: boolean, passive: boolean, signal: AbortSignal, mozSystemGroup: boolean}
 * } [delegatedCallbackOrOptions]
 * The callback to run when the event is delegated or the options to apply to the listener
 * @param {{capture: boolean, once: boolean, passive: boolean, signal: AbortSignal, mozSystemGroup: boolean}} [options]
 * The options to apply to the listener
 * @returns {jLight} jLight collection
 */

/* eslint-enable max-len */

/**
 * @callback offCallback
 * @param {string} eventNames Space separated list of event names
 * @param {Function} [callback] The function to remove from being executed when the event occurs
 * @returns {jLight} jLight collection
 */

/**
 * @callback delegateCallback
 * @param {string} eventNames Space separated list of event names
 * @param {Function} callback The function to apply
 * @returns {jLight} jLight collection
 */

/**
 * @callback triggerCallback
 * @param {string} eventNames Space separated list of event names
 * @param {*} [jLightEventData] Custom data passed to the event
 * @returns {jLight} jLight collection
 */

/**
 * @callback propCallback
 * @param {string} property The property to set or get
 * @param {boolean} [state] The state to set the property to
 * @returns {jLight|boolean}
 * jLight collection or if the property is set on at least one of the collections elements
 */

/**
 * @callback attrCallback
 * @param {string|Object.&lt;string, *>} [attribute] The attribute or attributes to set or get
 * @param {*} [value] The value to set the attribute to
 * @returns {jLight|Object.&lt;string, string>|boolean}
 * jLight collection, the attributes value, an object of each attribute on the
 * collections elements or if the attribute whether present on at least one of
 * the collections elements
 */

/**
 * @callback removeAttrCallback
 * @param {string|string[]} attribute The attribute or attributes to remove
 * @returns {jLight} jLight collection
 */

/**
 * @callback iteratorCallback
 * @param {jLight} [$element] The current jLight element
 * @param {number} [index] The current index
 * @returns {void} void
 */

/**
 * @callback valCallback
 * @param {boolean|null|string|boolean[]|Function|iteratorCallback} [valueOrFunction]
 * The value to set the collections elements value to.
 * If a function is supplied its return value will be set as the value.
 * If the jLight element is an HTMLSelectElement with the multiple
 * attribute each option will be passed separately to the function.
 * In that case an array of booleans can be used to set the selected options.
 * @returns {jLight|boolean|string} jLight collection or the value
 */

/**
 * @callback dataCallback
 * @param {string|Object.&lt;string, *>} [keyOrData] The key of the data value to get or set or
 * an object of data values to set.
 * @param {string|string[]} [value] The value to set the data at the supplied key to.
 * @returns {jLight|*} jLight collection
 */

/**
 * @callback cloneCallback
 * @param {boolean} [deep] Whether to apply deep cloning of the affected nodes (default: true)
 * @returns {jLight} jLight collection
 */

/**
 * @callback elementsCallback
 * @param {jLight|string|HTMLElement|HTMLCollection|NodeList} elements
 * The elements to apply the function to
 * @returns {jLight} jLight collection
 */

/**
 * @callback removeCallback
 * @param {jLight|string|HTMLElement|HTMLCollection|NodeList} [elements] The elements to remove
 * @param {boolean} [removeFromDom]
 * Whether the elements should also be removed from the DOM (default: true)
 * @returns {jLight|null} jLight collection or null
 */

/**
 * @callback contentCallback
 * @param {string} [content] The content to supply to the function
 * @returns {jLight|string} jLight collection or the text content
 */

/**
 * @callback indexElementCallback
 * @param {number} index The index to supply to the function
 * @returns {HTMLElement|undefined} The element or null
 */

/**
 * @callback indexjLightCallback
 * @param {number} index The index to supply to the function
 * @returns {jLight} jLight collection
 */

/**
 * @callback selectorCallback
 * @param {string} [selector] The selector to use for matching elements
 * @returns {jLight} jLight collection
 */

/**
 * @callback elementsBooleanCallback
 * @param {jLight|string|HTMLElement|HTMLCollection|NodeList} elements
 * The elements to supply to the function
 * @returns {boolean} If the conditon is met
 */

/**
 * @callback filterCallback
 * @param {string|iteratorCallback} callbackOrSelector
 * The selector to filter the collection by or a custom
 * function to decide which elements to filter out
 * @returns {jLight} jLight collection
 */

/**
 * @callback outerIteratorCallback
 * @param {iteratorCallback} callback The function to apply to each element
 * @returns {jLight} jLight collection
 */

/**
 * @callback sliceCallback
 * @param {number} [start] The index to start the slicing
 * @param {number} [end] The index to end the slicing
 * @returns {jLight} jLight collection
 */

/**
 * @callback spliceCallback
 * @param {number} start The index to start the splicing
 * @param {number} [deleteCount] The count of elements to delete
 * @returns {jLight} jLight collection
 */

/**
 * @callback arrayLengthCallback
 * @param {...(jLight|string|HTMLElement|HTMLCollection|NodeList)} elements
 * The elements to apply to the function.
 * @returns {number} The collections new length
 */

/**
 * @callback compareCallback
 * @param {jLight} $element1 The element to compare
 * @param {jLight} $element2 The element to compare to
 * @returns {number} The value to determine which place the element to compare will take
 */

/**
 * @callback sortCallback
 * @param {compareCallback} compareFunction The function used for sorting
 * @returns {jLight} jLight collection
 */

/**
 * @callback reduceInnerCallback
 * @param {*} accumulator The accumulated value
 * @param {jLight} $element The current element
 * @param {number} [index] The current elements index
 * @returns {*} The current reduction result
 */

/**
 * @callback reduceCallback
 * @param {reduceInnerCallback} callback The function used for reduction
 * @param {*} [initialValue] The initial value used for reduction
 * @returns {*} The reduction result
 */

/**
 * @callback mapInnerCallback
 * @param {jLight} [$element] The current element
 * @param {number} [index] The current elements index
 * @returns {jLight|string|HTMLElement|HTMLCollection|NodeList} The elements to map
 */

/**
 * @callback mapCallback
 * @param {mapInnerCallback} callback The function used for mapping
 * @returns {jLight} jLight collection
 */

/**
 * @callback multipleElementsCallback
 * @param {...(jLight|string|HTMLElement|HTMLCollection|NodeList|
 * Array.&lt;jLight|string|HTMLElement|HTMLCollection|NodeList>)} elements
 * The elements to apply to the function.
 * @returns {jLight} jLight collection
 */

/**
 * @callback iteratorBooleanCallback
 * @param {jLight} [$element] The current jLight element
 * @param {number} [index] The current index
 * @returns {boolean} Whether the condition is met
 */

/**
 * @callback arrayBooleanCallback
 * @param {iteratorBooleanCallback} callback
 * The elements to supply to the function
 * @returns {boolean} If the conditon is met
 */

/**
 * @callback elementsNumberCallback
 * @param {jLight|string|HTMLElement|HTMLCollection|NodeList} elements
 * The elements to supply to the function
 * @returns {number} The resulting number
 */

/**
 * @callback getOrSetValueCallback
 * @param {number} [value] The value to supply to the function
 * @returns {jLight|number} jLight collection or the value
 */

/**
 * @callback dimensionCallback
 * @returns {number} The dimension value
 */

/**
 * @callback outerDimensionCallback
 * @param {boolean} [includeMargins] Whether to include the elements margins (default: false)
 * @returns {number} The dimension value
 */

/**
 * @callback offsetCallback
 * @param {boolean|{top: number, left: number}} [value]
 * The value to set the elements offset to or if the
 * returned offset should be relative to the viewport
 * @param {boolean} [relativeToViewport]
 * Whether the offset should be set relative to the viewport (default: false)
 * @returns {jLight|{top: number, left: number}} jLight collection or elements offset
 */

/**
 * @callback animateCallback
 * @param {Object.&lt;string, string>} [properties] The css properties and values to animate
 * @param {number} [duration] The duration for the animation in ms (default: 300)
 * @param {Function} [callback] The function to run after the animation is complete (default: noop)
 * @param {string} [easing] Which type of css easing to use for the animation (default: 'ease')
 * @returns {jLight} jLight collection
 */

/**
 * @callback scrollToCallback
 * @param {jLight|string|HTMLElement|HTMLCollection|NodeList} elements
 * The elements to scroll the collections elements to
 * @param {number} [duration] The duration of the scroll animation in ms (default: 300)
 * @param {{x: number, y: number}|{}} [offset] The offset for the target position
 * @param {Function} [callback] The function to run after the scrolling is complete
 * @returns {jLight} jLight collection
 */

/**
 * @callback animateOutCallback
 * @param {number} [duration] The duration for the animation in ms (default: 300)
 * @param {Function} [callback] The function to run after the animation is complete (default: noop)
 * @param {string} [easing] Which type of css easing to use for the animation (default: 'ease')
 * @returns {jLight} jLight collection
 */

/**
 * @callback fadeCallback
 * @param {number} [duration] The duration for the animation in ms (default: 300)
 * @param {Function} [callback] The function to run after the animation is complete (default: noop)
 * @param {string} [easing] Which type of css easing to use for the animation (default: 'ease')
 * @param {string} [type]
 * The css display type to apply to the collections elements
 * @returns {jLight} jLight collection
 */

/**
 * @callback fadeToggleCallback
 * @param {number} [duration] The duration for the animation in ms (default: 300)
 * @param {Function} [callback] The function to run after the animation is complete (default: noop)
 * @param {string} [easing] Which type of css easing to use for the animation (default: 'ease')
 * @param {string} [type]
 * The css display type to apply to the collections elements
 * @param {boolean} [force] Force whether to fade in or out
 * @returns {jLight} jLight collection
 */

/**
 * @callback slideCallback
 * @param {number} [duration] The duration for the animation in ms (default: 300)
 * @param {Function} [callback] The function to run after the animation is complete (default: noop)
 * @param {string} [easing] Which type of css easing to use for the animation (default: 'ease')
 * @param {string} [type]
 * The css display type to apply to the collections elements
 * @param {string} [height] The css height value to end the sliding animation
 * @returns {jLight} jLight collection
 */

/**
 * @callback slideToggleCallback
 * @param {number} [duration] The duration for the animation in ms (default: 300)
 * @param {Function} [callback] The function to run after the animation is complete (default: noop)
 * @param {string} [easing] Which type of css easing to use for the animation (default: 'ease')
 * @param {string} [type]
 * The css display type to apply to the collections elements
 * @param {string} [height] The css height value to end the sliding animation
 * @param {boolean} [force] Force whether to slide down or up
 * @returns {jLight} jLight collection
 */

/**
 * @callback isCallback
 * @param {jLight|string|HTMLElement|HTMLCollection|NodeList} propertyOrElements
 * The property or set to compare the collections elements to
 * @returns {boolean} If the property is set on one of the collections elements or
 * at least on of the elements is contained in the supplied elements
 */

/**
 * @callback inViewCallback
 * @param {Function|{top: number, bottom: number, left: number, right: number}} [offsetOrCallback]
 * The offset used for determining if the element is in view
 * or the function to run each time that is the case
 * @param {Function|
 *  {scrollTimer: ?number, isInView: ?Function, onEnter: ?Function, onExit: ?Function}
 * } [callbackOrOptions]
 * The function to run each time the element is in view
 * or a custom options object to define the functions behavior
 * (defaults: { scrollTimer: 100, isInView: noop, onEnter: noop, onExit: noop })
 * @returns {jLight|boolean} jLight collection or whether the collections first element is in view
 */

/**
 * @callback delayCallback
 * @param {number} [delay] The duration to delay the code execution for
 * @returns {Promise} The corresponding promise
 */

/**
 * @callback whenCallback
 * @param {boolean|Function} condition The condition to check for.
 * If a function is supplied its return value will be used for checking
 * @param {string|Function} callback The function to run when the condition is met.
 * If a string is provided it should be a valid jLight function name
 * @param {...*} [args] The arguments to supply to the given jLight function
 * @returns {jLight} jLight collection
 */

/**
 * @callback stringCallback
 * @returns {string} The resulting string
 */

/**
 * @callback stringObjectCallback
 * @returns {Object.&lt;string, string>} The resulting JSON object
 */

/* eslint-disable jsdoc/valid-types */

/**
 * @callback
 */

/* eslint-enable jsdoc/valid-types */

const jLightGlobalElements = [];
const jLightGlobalData = [];

/**
 * @module Utility
 * @tutorial tut-utility
 */

/**
 * Provides an empty function.
 *
 * @static
 * @function
 * @tutorial noop
 * @returns {void} void
 */
const noop = () => { };

/**
 * Generates a semi-random string of length 9.
 *
 * @static
 * @function
 * @tutorial uniqid
 * @returns {string} The generated string
 */
const uniqid = () => Math.random().toString(36).substr(2, 9);

/* eslint-disable no-bitwise */

/**
 * Generates a unique number hash from a string.
 *
 * @static
 * @function
 * @tutorial generateHash
 * @param {string} string The string to hash
 * @returns {number} The converted string
 */
const generateHash = (string) => Math.abs(string.split('').reduce((hash, b) => {
  const a = ((hash &lt;&lt; 5) - hash) + b.charCodeAt(0);

  return a &amp; a;
}, 0));

/**
 * Checks if an object is empty.
 *
 * @static
 * @function
 * @tutorial isEmptyObject
 * @param {object} object The object to check
 * @returns {boolean} If the object is empty
 */
const isEmptyObject = (object) => object
  &amp;&amp; object.constructor === Object
  &amp;&amp; !Object.keys(object).length;

/**
 * Checks if two objects are the same.
 *
 * @static
 * @function
 * @tutorial isSameObject
 * @param {object} object1 The object to compare
 * @param {object} object2 The object to compare to
 * @returns {boolean} If the objects are the same
 */
const isSameObject = (object1, object2) => object1
  &amp;&amp; object2
  &amp;&amp; object1.constructor === Object
  &amp;&amp; object2.constructor === Object
  &amp;&amp; Object.is(object1, object2);

/**
 * Prevents the events default beheavior, propagation and immediate propagation
 *
 * @static
 * @function
 * @tutorial preventEvent
 * @param {Event} event The event to prevent
 * @returns {void} void
 */
const preventEvent = (event) => {
  event.preventDefault();
  event.stopPropagation();
  event.stopImmediatePropagation();
};

/**
 * Provides easing functionality using easeInOutCubic.
 *
 * @static
 * @function
 * @tutorial doEasing
 * @param {number} duration The duration over which to apply the easing
 * @param {onStepCallback} onStep The function to run at each easing step
 * @param {Function} [callback] The function to run after the easing is complete
 * @returns {void} void
 */
const doEasing = (duration, onStep, callback) => {
  let start;

  const easing = (t) => (t &lt; 0.5
    ? 4 * t * t * t
    : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1);

  const step = (timestamp) => {
    if (!start) {
      start = timestamp;
    }

    const time = timestamp - start;

    onStep(easing(Math.min(time / duration, 1)));

    if (time &lt; duration) {
      window.requestAnimationFrame(step);
    } else if (callback) {
      callback();
    }
  };

  window.requestAnimationFrame(step);
};

/**
 * @module String
 * @tutorial tut-string
 */

/**
 * Converts the first character of a string to lowercase.
 *
 * @static
 * @function
 * @tutorial lcfirst
 * @param {string} string The string to convert
 * @returns {string} The converted string
 */
const lcfirst = (string) => string.charAt(0).toLowerCase() + string.slice(1);

/**
 * Converts the first character of a string to uppercase.
 *
 * @static
 * @function
 * @tutorial ucfirst
 * @param {string} string The string to convert
 * @returns {string} The converted string
 */
const ucfirst = (string) => string.charAt(0).toUpperCase() + string.slice(1);

/**
 * Converts a string from camel case to kebap case.
 *
 * @static
 * @function
 * @tutorial camelToKebab
 * @param {string} string The string to convert
 * @returns {string} The converted string
 */
const camelToKebab = (string) => (typeof string === 'string'
  ? string.replace(/([a-z][A-Z])/g, (chars) => `${chars[0]}-${chars[1].toLowerCase()}`).toLowerCase()
  : '');

/**
 * Converts a string from camel case to snake case.
 *
 * @static
 * @function
 * @tutorial camelToSnake
 * @param {string} string The string to convert
 * @returns {string} The converted string
 */
const camelToSnake = (string) => (typeof string === 'string'
  ? lcfirst(string).replace(/[A-Z]/g, (char) => `_${char.toLowerCase()}`).toLowerCase()
  : '');

/**
 * Converts a string from kebap case to camel case.
 *
 * @static
 * @function
 * @tutorial kebabToCamel
 * @param {string} string The string to convert
 * @returns {string} The converted string
 */
const kebabToCamel = (string) => (typeof string === 'string'
  ? lcfirst(string.replace(/-([a-zA-Z])/g, (chars) => chars[1].toUpperCase()))
  : '');

/**
 * Converts a string from kebap case to snake case.
 *
 * @static
 * @function
 * @tutorial kebabToSnake
 * @param {string} string The string to convert
 * @returns {string} The converted string
 */
const kebabToSnake = (string) => (typeof string === 'string'
  ? string.replace(/-/g, '_').toLowerCase()
  : '');

/**
 * Converts a string from snake case to camel case.
 *
 * @static
 * @function
 * @tutorial snakeToCamel
 * @param {string} string The string to convert
 * @returns {string} The converted string
 */
const snakeToCamel = (string) => (typeof string === 'string'
  ? lcfirst(string.replace(/(_[a-zA-Z])/g, (chars) => chars[1].toUpperCase()))
  : '');

/**
 * Converts a string from snake case to kebap case.
 *
 * @static
 * @function
 * @tutorial snakeToKebab
 * @param {string} string The string to convert
 * @returns {string} The converted string
 */
const snakeToKebab = (string) => (typeof string === 'string'
  ? string.replace(/_/g, '-').toLowerCase()
  : '');

/* eslint-enable no-bitwise */

/**
 * @module Ajax
 * @tutorial tut-ajax
 */

/**
 * Handles asynchronous HTTP requests.
 *
 * @static
 * @function
 * @tutorial ajax
 * @param {object} opts The options for the request
 * @param {string} opts.url The url to send the request to
 * @param {string} [opts.method] The HTTP method to use (default: 'POST')
 * @param {Object.&lt;string, *>|string} [opts.data] The data to send
 * @param {Object.&lt;string, string>} [opts.headers] The headers to send
 * @param {boolean} [opts.processData] Whether to process the data or not
 * @param {boolean} [opts.crossDomain] Whether to send the request cross domain or not
 * @param {boolean} [opts.async] Whether to send the request asynchronously or not
 * @param {string|false} [opts.contentType] The content type to use
 * @param {string|null} [opts.username] The username to use for authentification
 * @param {string|null} [opts.password] The password to use for authentification
 * @param {ajaxCompleteCallback} [opts.done] The callback to run if the request was successful
 * @param {ajaxCompleteCallback} [opts.fail] The callback to run if the request has failed
 * @param {ajaxCompleteCallback} [opts.always] The callback to run always
 * @param {Function} [opts.abort] The callback to run if the request was aborted
 * @param {xhrCallback} [opts.xhr] The callback to modify the XMLHttpRequest object before sending
 * @returns {XMLHttpRequest} The corresponding XMLHttpRequest object
 */
const ajax = (opts = {}) => {
  const options = {
    url: window.location.href,
    method: 'POST',
    data: {},
    headers: {},
    processData: true,
    crossDomain: false,
    async: true,
    contentType: 'application/x-www-form-urlencoded',
    username: null,
    password: null,
    done: noop,
    fail: noop,
    always: noop,
    abort: noop,
    xhr: (request) => request,
    ...opts,
  };

  const request = options.xhr(new XMLHttpRequest());
  const { headers } = options;
  let { data } = options;

  options.method = options.method.toUpperCase();

  if (!options.crossDomain &amp;&amp; !headers['X-Requested-With']) {
    headers['X-Requested-With'] = 'XMLHttpRequest';
  }

  if (!headers['Content-Type']) {
    headers['Content-Type'] = options.contentType;
  }

  if (headers['Content-Type'] === false) {
    delete headers['Content-Type'];
  }

  if (options.processData &amp;&amp; typeof data !== 'string') {
    if (headers['Content-Type'] === 'application/json') {
      data = JSON.stringify(data);
    } else if (data &amp;&amp; typeof data === 'object') {
      const params = [];

      Object.entries(data).forEach(([theKey, value]) => {
        const key = theKey;

        if (Array.isArray(value)) {
          value.forEach((item) => {
            params.push(`${key}[]=${item}`);
          });
        } else {
          params.push(`${key}=${value}`);
        }
      });

      data = params.join('&amp;');
    }
  }

  request.open(
    options.method,
    `${options.url}${options.method === 'GET' ? `?${data}` : ''}`,
    options.async,
    options.username,
    options.password,
  );

  Object.entries(headers).forEach(([key, value]) => {
    request.setRequestHeader(key, value);
  });

  const fail = () => options.fail(
    request.response,
    request.status,
    request,
  );

  request.onerror = fail;
  request.ontimeout = fail;
  request.onabort = options.abort;

  request.onreadystatechange = () => {
    if (request.readyState === XMLHttpRequest.DONE) {
      if (request.status &amp;&amp; request.status >= 200 &amp;&amp; request.status &lt; 300) {
        const isJsonResponse = (request.getResponseHeader('content-type') || '')
          .includes('application/json');

        options.done(
          isJsonResponse
            ? JSON.parse(request.response)
            : request.response,
          request.status,
          request,
        );
      } else if (request.status) {
        fail();
      }

      options.always(
        request.response,
        request.status,
        request,
      );
    }
  };

  request.send(options.method === 'POST' ? data : null);

  return request;
};

/**
 * Handles asynchronous GET requests.
 *
 * @static
 * @function
 * @tutorial ajax-get
 * @param {string} url The url for the request
 * @param {object} opts The options for the request
 * @param {Object.&lt;string, *>|string} [opts.data] The data to send
 * @param {Object.&lt;string, string>} [opts.headers] The headers to send
 * @param {boolean} [opts.processData] Whether to process the data or not
 * @param {boolean} [opts.crossDomain] Whether to send the request cross domain or not
 * @param {boolean} [opts.async] Whether to send the request asynchronously or not
 * @param {string|false} [opts.contentType] The content type to use
 * @param {string|null} [opts.username] The username to use for authentification
 * @param {string|null} [opts.password] The password to use for authentification
 * @param {ajaxCompleteCallback} [opts.done] The callback to run if the request was successful
 * @param {ajaxCompleteCallback} [opts.fail] The callback to run if the request has failed
 * @param {ajaxCompleteCallback} [opts.always] The callback to run always
 * @param {Function} [opts.abort] The callback to run if the request was aborted
 * @param {xhrCallback} [opts.xhr] The callback to modify the XMLHttpRequest object before sending
 * @returns {XMLHttpRequest} The corresponding XMLHttpRequest object
 */
const get = (url, opts = {}) => ajax({
  ...opts,
  method: 'GET',
  url,
});

/**
 * Handles asynchronous POST requests.
 *
 * @static
 * @function
 * @tutorial ajax-post
 * @param {string} url The url for the request
 * @param {object} opts The options for the request
 * @param {Object.&lt;string, *>|string} [opts.data] The data to send
 * @param {Object.&lt;string, string>} [opts.headers] The headers to send
 * @param {boolean} [opts.processData] Whether to process the data or not
 * @param {boolean} [opts.crossDomain] Whether to send the request cross domain or not
 * @param {boolean} [opts.async] Whether to send the request asynchronously or not
 * @param {string|false} [opts.contentType] The content type to use
 * @param {string|null} [opts.username] The username to use for authentification
 * @param {string|null} [opts.password] The password to use for authentification
 * @param {ajaxCompleteCallback} [opts.done] The callback to run if the request was successful
 * @param {ajaxCompleteCallback} [opts.fail] The callback to run if the request has failed
 * @param {ajaxCompleteCallback} [opts.always] The callback to run always
 * @param {Function} [opts.abort] The callback to run if the request was aborted
 * @param {xhrCallback} [opts.xhr] The callback to modify the XMLHttpRequest object before sending
 * @returns {XMLHttpRequest} The corresponding XMLHttpRequest object
 */
const post = (url, opts = {}) => ajax({
  method: 'POST',
  url,
  ...opts,
});

const initalizeJLightElementData = (element, selector) => {
  if (jLightGlobalElements.indexOf(element) > -1) {
    return;
  }

  jLightGlobalElements.push(element);

  jLightGlobalData[jLightGlobalElements.length - 1] = {
    jLightInternal: { selector },
  };
};

const removeJLightElementData = (element) => {
  const elementIndex = jLightGlobalElements.indexOf(element);

  if (elementIndex &lt; 0) {
    return;
  }

  jLightGlobalElements.splice(elementIndex, 1);
  jLightGlobalData.splice(elementIndex, 1);
};

const getJLightElementData = (element) => {
  const elementIndex = jLightGlobalElements.indexOf(element);

  if (elementIndex > -1) {
    return jLightGlobalData[elementIndex];
  }

  initalizeJLightElementData(element, element);

  return getJLightElementData(element);
};

const setJLightElementData = (element, key, value) => {
  const elementIndex = jLightGlobalElements.indexOf(element);

  if (elementIndex > -1) {
    jLightGlobalData[elementIndex][key] = value;

    return;
  }

  initalizeJLightElementData(element, element);
  setJLightElementData(element, key, value);
};

const updateJLightElementData = (element, data) => {
  const elementIndex = jLightGlobalElements.indexOf(element);

  if (elementIndex > -1) {
    jLightGlobalData[elementIndex] = {
      ...jLightGlobalData[elementIndex],
      ...data,
    };

    return;
  }

  initalizeJLightElementData(element, element);
  updateJLightElementData(element, data);
};

const addJLightElementEventData = (element, type, callback, realCallback) => {
  const jLightElementData = getJLightElementData(element);
  const events = jLightElementData.jLightInternal.events || [];

  events.push({
    type,
    callback,
    realCallback,
  });

  updateJLightElementData(element, {
    jLightInternal: {
      ...jLightElementData.jLightInternal,
      events,
    },
  });
};

const removeJLightElementEventData = (element, type, callback, realCallback) => {
  const jLightElementData = getJLightElementData(element);
  const events = jLightElementData.jLightInternal.events || [];

  updateJLightElementData(element, {
    jLightInternal: {
      ...jLightElementData.jLightInternal,
      events: events.filter((event) => event.type !== type
        || event.callback !== callback
        || event.realCallback !== realCallback),
    },
  });
};

const createElementsFromString = (string) => {
  const div = document.createElement('div');

  div.innerHTML = string.trim();

  const { children } = div;

  [...children].forEach((theChild) => {
    let child = theChild;

    if (!(child instanceof HTMLElement)) {
      const fallbackDiv = document.createElement('div');

      fallbackDiv.textContent = child.textContent;
      child = fallbackDiv;
    }

    initalizeJLightElementData(child, child.tagName.toLowerCase());
  });

  return children;
};

const getElementsFromArgument = (argument) => {
  if (argument.elements) {
    return argument.elements;
  }

  if (typeof argument === 'string') {
    return argument.match(/&lt;(.|\n)+>/)
      ? [...createElementsFromString(argument)]
      : [...document.querySelectorAll(argument)];
  }

  if (argument instanceof HTMLElement) {
    return [argument];
  }

  if (argument instanceof HTMLCollection || argument instanceof NodeList) {
    return [...argument];
  }

  return [];
};

const getElementStyle = (element, property) => {
  const computedStyles = window.getComputedStyle(element);

  return computedStyles.getPropertyValue(property);
};

const updateJLightDisplayData = (element, display) => {
  updateJLightElementData(element, {
    jLightInternal: {
      ...(getJLightElementData(element).jLightInternal || {}),
      display,
    },
  });
};

const getPrevMatchingElement = (element, selector) => {
  const prev = element.previousElementSibling;

  if (prev &amp;&amp; prev.matches(selector)) {
    return prev;
  }

  if (prev) {
    return getPrevMatchingElement(prev, selector);
  }

  return null;
};

const getNextMatchingElement = (element, selector) => {
  const next = element.nextElementSibling;

  if (next &amp;&amp; next.matches(selector)) {
    return next;
  }

  if (next) {
    return getNextMatchingElement(next, selector);
  }

  return null;
};

const getParents = (elements, all, isRecursing) => {
  const parents = [];

  elements.forEach(({ parentElement }) => {
    if (!parents.includes(parentElement)) {
      if (isRecursing &amp;&amp; elements.includes(parentElement)) {
        return;
      }

      parents.push(parentElement);
    }
  });

  if (all &amp;&amp; !parents.includes(document.documentElement)) {
    return [...parents, ...getParents(parents, all, true)];
  }

  return parents;
};

const getClosestMatchingElement = (element, selector) => {
  const closest = element.parentElement;

  // eslint-disable-next-line no-nested-ternary
  return closest
    ? closest.matches(selector)
      ? closest
      : getClosestMatchingElement(closest, selector)
    : undefined;
};

const canBeSeralized = (element) => (element.name
  &amp;&amp; (element instanceof HTMLInputElement
    || element instanceof HTMLTextAreaElement
    || element instanceof HTMLSelectElement));

const addValueToJson = (element, theSerializedJson) => {
  const serializedJson = theSerializedJson;

  if (element.getAttribute('type') === 'checkbox') {
    serializedJson[element.name] = element.checked;
  } else {
    serializedJson[element.name] = element.value;
  }

  return serializedJson;
};

const getUpdateAnimationId = (element) => {
  const jLightElementData = getJLightElementData(element).jLightInternal || {};
  const animationId = uniqid();

  updateJLightElementData(element, {
    jLightInternal: {
      ...jLightElementData,
      currentAnimation: animationId,
    },
  });

  return animationId;
};

const attachListener = (
  jLight,
  elements,
  eventNames,
  callbackOrSelector,
  delegatedCallbackOrOptions,
  theOptions = {},
  theJLightConstructor,
) => {
  const jlightConstructor = theJLightConstructor || jLight;
  let types = [eventNames];

  if (types[0].indexOf(' ') > -1) {
    types = types[0].split(' ');
  }

  const hasDelegatedCallback = typeof delegatedCallbackOrOptions === 'function';
  const options = (hasDelegatedCallback ? theOptions : delegatedCallbackOrOptions) || {};
  const delegatedCallback = hasDelegatedCallback ? delegatedCallbackOrOptions : noop;
  const isDocumentOrWindow = elements[0]
    &amp;&amp; (elements[0] === document || elements[0] === window);

  if (typeof callbackOrSelector === 'function' || callbackOrSelector === false) {
    elements.forEach((element) => {
      const callback = (theEvent) => {
        const event = theEvent;

        event.$target = jlightConstructor([event.target]);
        event.$currentTarget = jLight([event.currentTarget]);

        if (callbackOrSelector === false
          || callbackOrSelector(event, event.jLightEventData) === false
          || delegatedCallback === false) {
          preventEvent(event);
        }
      };

      types.forEach((type) => {
        addJLightElementEventData(element, type, callbackOrSelector, callback);

        element.addEventListener(type, (event) => {
          if (options.once) {
            removeJLightElementEventData(element, type, callbackOrSelector, callback);
          }

          return callback(event);
        }, options);
      });
    });
  } else {
    types.forEach((type) => {
      elements.forEach((element) => {
        const callback = (theEvent) => {
          const event = theEvent;
          const contains = isDocumentOrWindow || element.contains(event.target);

          if (contains &amp;&amp; event.target.matches(callbackOrSelector)) {
            event.$target = jlightConstructor([event.target]);
            event.$currentTarget = jLight([event.currentTarget]);

            if (delegatedCallback === false
              || delegatedCallback(event, event.jLightEventData) === false) {
              preventEvent(event);
            }
          }

          if (options.once) {
            removeJLightElementEventData(element, type, delegatedCallback, callback);
          }
        };

        addJLightElementEventData(element, type, delegatedCallback, callback);
        element.addEventListener(type, callback, options);
      });
    });
  }

  return jLight(elements);
};

const removeListener = (jLight, elements, eventNames, callback) => {
  let types = [eventNames];

  if (types[0].indexOf(' ') > -1) {
    types = types[0].split(' ');
  }

  elements.forEach((element) => {
    const jLightElementData = getJLightElementData(element);
    const events = jLightElementData.jLightInternal.events || [];

    types.forEach((type) => {
      events.forEach((event) => {
        if (event.type === type &amp;&amp; (!callback || event.callback === callback)) {
          removeJLightElementEventData(element, type, callback, event.realCallback);
          element.removeEventListener(type, event.realCallback);
        }
      });
    });
  });

  return jLight(elements);
};

const triggerListener = (jLight, elements, eventNames, jLightEventData) => {
  const nativeTypes = ['click', 'focus', 'focusin', 'blur', 'focusout'];
  let types = [eventNames];

  if (types[0].indexOf(' ') > -1) {
    types = types[0].split(' ');
  }

  types.forEach((type) => {
    if (!jLightEventData &amp;&amp; nativeTypes.includes(type)) {
      let hasFired;

      elements.forEach((element) => {
        if (type === 'click' &amp;&amp; element.click) {
          element.click();

          hasFired = true;
        } else if ((type === 'focus' || type === 'focusin') &amp;&amp; element.focus) {
          element.focus();

          hasFired = true;
        } else if ((type === 'blur' || type === 'focusout') &amp;&amp; element.blur) {
          element.blur();

          hasFired = true;
        }
      });

      if (hasFired) {
        return;
      }
    }

    const event = document.createEvent('Event');

    event.jLightEventData = jLightEventData;
    event.initEvent(type, true, true);

    elements.forEach((element) => {
      element.dispatchEvent(event);
    });
  });

  return jLight(elements);
};

const indexOfOfLastIndexOf = (identifier, elements, $elements) => {
  const theElements = getElementsFromArgument($elements);
  const isLast = identifier === 'lastIndexOf';
  let index = -1;

  theElements.forEach((referenceElement) => {
    if ((index &lt; 0 &amp;&amp; !isLast) || isLast) {
      index = elements[identifier](referenceElement);
    }
  });

  return index;
};

const getOrSetDimension = (identifier, $elements, value) => {
  const { elements } = $elements;

  if (value !== undefined) {
    elements.forEach((theElement) => {
      const element = theElement;

      element.style[identifier] = `${value}${typeof value !== 'string' ? 'px' : ''}`;
    });

    return $elements;
  }

  const upperIdentifier = ucfirst(identifier);
  let dimension;

  elements.forEach((element) => {
    if (dimension === undefined) {
      dimension = Math.max(
        element[`client${upperIdentifier}`],
        element[`offset${upperIdentifier}`],
      );
    }
  });

  return dimension;
};

const getDimension = (identifier, elements, includeMargins) => {
  let dimension = 0;
  let spacingOne;
  let spacingTwo;
  let functionSuffix;

  switch (identifier) {
    case 'innerWidth':
      spacingOne = 'border-left';
      spacingTwo = 'border-right';
      functionSuffix = 'Width';

      break;
    case 'innerHeight':
      spacingOne = 'border-top';
      spacingTwo = 'border-bottom';
      functionSuffix = 'Height';

      break;
    case 'outerWidth':
      spacingOne = 'margin-left';
      spacingTwo = 'margin-right';
      functionSuffix = 'Width';

      break;
    case 'outerHeight':
      spacingOne = 'margin-top';
      spacingTwo = 'margin-bottom';
      functionSuffix = 'Height';

      break;
    default:
      break;
  }

  elements.forEach((element) => {
    if (dimension) {
      return;
    }

    let spacingLeftOrTop = 0;
    let spacingRightOrBottom = 0;
    const computedStyles = window.getComputedStyle(element);
    const isInner = identifier.indexOf('inner') > -1;

    if (isInner || includeMargins) {
      const sign = isInner ? -1 : 1;

      spacingLeftOrTop = sign * parseFloat(computedStyles.getPropertyValue(spacingOne), 10);
      spacingRightOrBottom = sign * parseFloat(computedStyles.getPropertyValue(spacingTwo), 10);
    }

    dimension = Math.max(
      element[`client${functionSuffix}`],
      element[`offset${functionSuffix}`],
    ) + spacingLeftOrTop + spacingRightOrBottom;
  });

  return dimension;
};

const getOrSetTextOrHtml = (identifier, $elements, theValue) => {
  const { elements } = $elements;
  let value = theValue;

  if (value || typeof value === 'number' || typeof value === 'string' || value === null) {
    elements.forEach((theElement, index) => {
      const element = theElement;

      if (typeof value === 'function') {
        value = theValue(index, element[identifier]);
      }

      element[identifier] = value === 0 ? '0' : (value || '');
    });

    return $elements;
  }

  elements.forEach((element) => {
    if (value === undefined) {
      value = element[identifier];
    }
  });

  return value;
};

const modifyClasses = (identifier, $elements, cssString = '', force) => {
  const { elements } = $elements;
  const isToggle = identifier === 'toggle';
  const removeAll = identifier === 'remove' &amp;&amp; !cssString.trim();
  let cssClasses = [cssString];

  if (cssString.indexOf(' ') > -1) {
    cssClasses = cssString.split(' ');
  }

  elements.forEach((element) => {
    cssClasses.forEach((cssClass) => {
      if (isToggle) {
        element.classList.toggle(cssClass, force);
      } else if (removeAll) {
        element.classList.remove(...element.classList);
      } else {
        element.classList[identifier](cssClass);
      }
    });
  });

  return $elements;
};

const prependOrAppend = (identifier, $elements, elements) => {
  const theElements = getElementsFromArgument($elements);

  elements.forEach((element) => {
    theElements.forEach((elementToInsert) => {
      if (element !== elementToInsert) {
        element[identifier](elementToInsert);
      }
    });
  });

  return elements;
};

const prependToOrAppendTo = (identifier, $elements, elements) => {
  const theElements = getElementsFromArgument($elements);

  elements.forEach((element) => {
    theElements.forEach((elementToInsertTo) => {
      if (element !== elementToInsertTo) {
        elementToInsertTo[identifier](element);
      }
    });
  });

  return elements;
};

const insertBeforeOrInsertAfter = (identifier, $elements, elements, type) => {
  const theElements = getElementsFromArgument($elements);

  elements.forEach((element) => {
    theElements.forEach((referenceElement) => {
      if (element !== referenceElement) {
        if (type === 'insert') {
          referenceElement.insertAdjacentElement(identifier, element);
        } else {
          element.insertAdjacentElement(identifier, referenceElement);
        }
      }
    });
  });

  return elements;
};

const getPrevOrNextElements = (identifier, selector, elements) => {
  const theElements = [];

  if (!selector) {
    elements.forEach((element) => {
      const theElement = element[identifier];

      if (theElement &amp;&amp; !theElements.includes(theElement)) {
        theElements.push(theElement);
      }
    });
  } else {
    const isPrev = identifier === 'previousElementSibling';
    let theElement;

    elements.forEach((element) => {
      if (isPrev) {
        theElement = getPrevMatchingElement(element, selector);
      } else {
        theElement = getNextMatchingElement(element, selector);
      }

      if (theElement &amp;&amp; !theElements.includes(theElement)) {
        theElements.push(theElement);
      }
    });
  }

  return theElements;
};

const getScrollWidthOrScrollHeight = (identifier, elements) => {
  let dimension = 0;

  elements.forEach((element) => {
    if (dimension === undefined) {
      dimension = element[identifier];
    }
  });

  return dimension;
};

const getOrSetScrollTopOrScrollLeft = (identifier, value, $elements) => {
  const { elements } = $elements;

  if (value !== undefined) {
    elements.forEach((theElement) => {
      const element = theElement;

      element[identifier] = parseFloat(value, 10);
    });

    return $elements;
  }

  let scrollValue;

  elements.forEach((element) => {
    if (scrollValue === undefined) {
      scrollValue = element[identifier];
    }
  });

  return scrollValue;
};

const isInView = (boundingBox, offset) => boundingBox.top >= parseFloat(offset.top, 10)
  &amp;&amp; boundingBox.left >= parseFloat(offset.left, 10)
  &amp;&amp; boundingBox.bottom &lt;= (window.innerHeight || document.documentElement.clientHeight)
  + parseFloat(offset.bottom, 10)
  &amp;&amp; boundingBox.right &lt;= (window.innerWidth || document.documentElement.clientWidth)
  + parseFloat(offset.right, 10);

const jLight = (elements) => ({
  ...(() => {
    const theElements = {};

    elements.forEach((element, index) => {
      theElements[index] = element;
    });

    return theElements;
  })(),

  /**
   * @module Properties
   * @tutorial tut-properties
   */

  /**
   * The collections elements.
   *
   * @tutorial tut-properties
   * @type {HTMLElement[]}
   */
  elements,

  /**
   * The collections element count.
   *
   * @tutorial tut-properties
   * @type {number}
   */
  length: elements.filter((element) => element).length,

  /**
   * The collections first elements tag name.
   *
   * @tutorial tut-properties
   * @type {string}
   */
  tagName: elements[0] ? elements[0].tagName : undefined,

  /**
   * @module CSS
   * @tutorial tut-css
   */

  /**
   * Adds css classes to the collections elements.
   *
   * @function
   * @tutorial addClass
   * @param {string} cssClasses Space sepearated classes to add
   * @returns {jLight} jLight collection
   */
  addClass: (cssClasses) => modifyClasses('add', jLight(elements), cssClasses),

  /**
   * Removes css classes to the collections elements.
   *
   * @function
   * @tutorial removeClass
   * @param {string} cssClasses Space sepearated classes to remove
   * @returns {jLight} jLight collection
   */
  removeClass: (cssClasses) => modifyClasses('remove', jLight(elements), cssClasses),

  /**
   * Toggles css classes of the collections elements.
   *
   * @function
   * @tutorial toggleClass
   * @param {string} cssClasses Space sepearated classes to toggle
   * @param {boolean} [force] Force whether to add or remove classes
   * @returns {jLight} jLight collection
   */
  toggleClass: (cssClasses, force) => modifyClasses('toggle', jLight(elements), cssClasses, force),

  /**
   * Whether at least one of the collections elements has all of the provided classes.
   *
   * @function
   * @tutorial hasClass
   * @param {string} cssClasses Space sepearated classes to check for
   * @returns {boolean}
   * Whether at least one of the collections elements has all of the provided classes
   */
  hasClass: (cssClasses) => {
    let theCssClasses = [cssClasses];
    let hasClass;

    if (cssClasses.indexOf(' ') > -1) {
      theCssClasses = cssClasses.split(' ');
    }

    elements.forEach((element) => {
      if (hasClass !== undefined) {
        return;
      }

      let matchCount = 0;

      theCssClasses.forEach((cssClass) => {
        matchCount += element.classList.contains(cssClass) ? 1 : 0;
      });

      if (matchCount === theCssClasses.length) {
        hasClass = true;
      }
    });

    return hasClass || false;
  },

  /**
   * Applies style rules to the collections elements, gets the current style rules or
   * gets the current value for a specific style property.
   *
   * @function
   * @tutorial css
   * @param {string|Object.&lt;string, string>} [property] The property name or the properties to set
   * @param {string} [value] The value to set the supplied property to
   * @returns {jLight|string|CSSStyleDeclaration}
   * jLight collection, property value or elements CSSStyleDeclaration
   */
  css: (property, value) => {
    if (typeof property === 'object' &amp;&amp; property !== null) {
      elements.forEach((theElement) => {
        const element = theElement;

        Object.entries(property).forEach(([key, val]) => {
          element.style[key] = val;
        });
      });

      return jLight(elements);
    }

    if (value !== undefined) {
      elements.forEach((theElement) => {
        const element = theElement;

        element.style[property] = value;
      });

      return jLight(elements);
    }

    const computedStyles = elements[0]
      ? window.getComputedStyle(elements[0])
      : null;

    if (property) {
      return computedStyles.getPropertyValue(property);
    }

    return computedStyles || jLight(elements);
  },

  /**
   * Shows the collections elements.
   *
   * @function
   * @tutorial show
   * @param {string} [type]
   * The css display type to apply to the collections elements
   * @returns {jLight} jLight collection
   */
  show: (type) => {
    elements.forEach((theElement) => {
      const element = theElement;

      if (type) {
        element.style.display = type;

        return;
      }

      const { display } = getJLightElementData(element).jLightInternal;

      if (display) {
        element.style.display = display;

        return;
      }

      const computedDisplay = getElementStyle(element, 'display');

      if (computedDisplay !== 'none') {
        updateJLightDisplayData(element, computedDisplay);
        element.style.display = computedDisplay;
      } else {
        element.style.display = 'revert';
      }
    });

    return jLight(elements);
  },

  /**
   * Hides the collections elements.
   *
   * @function
   * @tutorial hide
   * @returns {jLight} jLight collection
   */
  hide: () => {
    elements.forEach((theElement) => {
      const element = theElement;
      const computedDisplay = getElementStyle(element, 'display');

      if (computedDisplay !== 'none') {
        updateJLightDisplayData(element, computedDisplay);
      }

      element.style.display = 'none';
    });

    return jLight(elements);
  },

  /**
   * Toggles the collections elements visibility.
   *
   * @function
   * @tutorial toggle
   * @param {string} [type] The css display type to apply to the function
   * @param {boolean} [force] Force whether to show or hide elements
   * @returns {jLight} jLight collection
   */
  toggle: (type, force) => {
    const forceDefined = force !== undefined;
    const forceShow = forceDefined &amp;&amp; force;
    const forceHide = forceDefined &amp;&amp; !force;

    elements.forEach((theElement) => {
      const element = theElement;

      if (forceShow || (getElementStyle(element, 'display') === 'none' &amp;&amp; !forceHide)) {
        jLight([element]).show(type);
      } else {
        jLight([element]).hide();
      }
    });

    return jLight(elements);
  },

  /**
   * @module Event
   * @tutorial tut-event
   */

  /* eslint-disable max-len */

  /**
   * Adds event handlers to elements.
   *
   * @function
   * @tutorial on
   * @param {string} eventNames Space separated list of event names
   * @param {eventCallback} callbackOrSelector The function to execute when the event occurs
   * or a selector to delegate events to children of the current collections elements
   * @param {eventCallback|
   *   {capture: boolean, once: boolean, passive: boolean, signal: AbortSignal, mozSystemGroup: boolean}
   * } [delegatedCallbackOrOptions]
   * The callback to run when the event is delegated or the options to apply to the listener
   * @param {{capture: boolean, once: boolean, passive: boolean, signal: AbortSignal, mozSystemGroup: boolean}} [options]
   * The options to apply to the listener
   * @returns {jLight} jLight collection
   */
  on: (eventNames, callbackOrSelector, delegatedCallbackOrOptions, options) => attachListener(
    jLight,
    elements,
    eventNames,
    callbackOrSelector,
    delegatedCallbackOrOptions,
    options,
  ),

  /**
   * Adds event handlers to elements fo one time execution.
   *
   * @function
   * @tutorial on
   * @param {string} eventNames Space separated list of event names
   * @param {eventCallback} callbackOrSelector The function to execute when the event occurs
   * or a selector to delegate events to children of the current collections elements
   * @param {eventCallback|
   *   {capture: boolean, once: boolean, passive: boolean, signal: AbortSignal, mozSystemGroup: boolean}
   * } [delegatedCallbackOrOptions]
   * The callback to run when the event is delegated or the options to apply to the listener
   * @param {{capture: boolean, once: boolean, passive: boolean, signal: AbortSignal, mozSystemGroup: boolean}} [options]
   * The options to apply to the listener
   * @returns {jLight} jLight collection
   */
  once: (eventNames, callbackOrSelector, delegatedCallbackOrOptions, options = {}) => attachListener(
    jLight,
    elements,
    eventNames,
    callbackOrSelector,
    delegatedCallbackOrOptions,
    {
      ...options,
      once: true,
    },
  ),

  /* eslint-enable max-len */

  /**
   * Removes event handlers from elements.
   *
   * @function
   * @tutorial off
   * @param {string} eventNames Space separated list of event names
   * @param {Function} [callback] The function to remove from being executed when the event occurs
   * @returns {jLight} jLight collection
   */
  off: (eventNames, callback) => removeListener(
    jLight,
    elements,
    eventNames,
    callback,
  ),

  /**
   * [DEPRECATED] Delegates event handlers to elements.
   *
   * @deprecated
   * Will be removed in version 1.2.0,
   * use [jLight]{@link jLight}.[on]{@link module:Event~on} instead
   * @function
   * @tutorial delegate
   * @param {string} eventNames Space separated list of event names
   * @param {Function} callback The function to execute when the event occurs
   * @returns {jLight} jLight collection
   */
  delegate: (eventNames, callback) => {
    // eslint-disable-next-line no-console
    console.warn('jLight.delegate is deprecated an will be removed in version 1.2.0, use jLight.on instead');

    let types = [eventNames];

    if (types[0].indexOf(' ') > -1) {
      types = types[0].split(' ');
    }

    const realCallback = (theEvent) => {
      const event = theEvent;
      const jLightElementData = getJLightElementData(elements[0]);
      const { selector } = jLightElementData.jLightInternal;

      if (!selector) {
        return;
      }

      if (event.target.matches(selector)) {
        event.$target = jLight([event.target]);
        event.$currentTarget = jLight([event.currentTarget]);

        if (callback === false
          || callback(event, event.jLightEventData) === false) {
          preventEvent(event);
        }
      }
    };

    types.forEach((type) => {
      addJLightElementEventData(document, type, callback, realCallback);
      document.addEventListener(type, realCallback);
    });

    return jLight(elements);
  },

  /**
   * [DEPRECATED] Undelegates event handlers from elements.
   *
   * @deprecated
   * Will be removed in version 1.2.0,
   * use [jLight]{@link jLight}.[off]{@link module:Event~off} instead
   * @function
   * @tutorial delegate
   * @param {string} eventNames Space separated list of event names
   * @param {Function} callback The function to remove
   * @returns {jLight} jLight collection
   */
  undelegate: (eventNames, callback) => {
    // eslint-disable-next-line no-console
    console.warn('jLight.undelegate is deprecated an will be removed in version 1.2.0, use jLight.off instead');

    const jLightElementData = getJLightElementData(document);
    const events = jLightElementData.jLightInternal.events || [];
    let types = [eventNames];

    if (types[0].indexOf(' ') > -1) {
      types = types[0].split(' ');
    }

    types.forEach((type) => {
      events.forEach((event) => {
        if (event.type === type &amp;&amp; event.callback === callback) {
          removeJLightElementEventData(document, type, callback, event.realCallback);
          document.removeEventListener(type, event.realCallback);
        }
      });
    });

    return jLight(elements);
  },

  /**
   * Triggers events on the collections elements.
   *
   * @function
   * @tutorial trigger
   * @param {string} eventNames Space separated list of event names
   * @param {*} [jLightEventData] Custom data passed to the event
   * @returns {jLight} jLight collection
   */
  trigger: (eventNames, jLightEventData) => triggerListener(
    jLight,
    elements,
    eventNames,
    jLightEventData,
  ),

  /**
   * @module ElementData
   * @tutorial tut-element-data
   */

  /**
   * Sets a property of the collections elements or gets its value.
   *
   * @function
   * @tutorial prop
   * @param {string} property The property to set or get
   * @param {boolean} [state] The state to set the property to
   * @returns {jLight|boolean}
   * jLight collection or if the property is set on at least one of the collections elements
   */
  prop: (property, state) => {
    if (state === undefined) {
      return elements[0][property];
    }

    elements.forEach((theElement) => {
      const element = theElement;

      if (element[property] !== undefined) {
        element[property] = state;
      }
    });

    return jLight(elements);
  },

  /**
   * Sets an attribute or attributes to the collections elements or gets its value or values.
   *
   * @function
   * @tutorial attr
   * @param {string|Object.&lt;string, *>} [attribute] The attribute or attributes to set or get
   * @param {*} [value] The value to set the attribute to
   * @returns {jLight|Object.&lt;string, string>|boolean}
   * jLight collection, the attributes value, an object of each attribute on the
   * collections elements or if the attribute whether present on at least one of
   * the collections elements
   */
  attr: (attribute, value) => {
    if (typeof attribute === 'object' &amp;&amp; attribute !== null) {
      Object.entries(attribute).forEach(([key, theValue]) => {
        elements.forEach((element) => {
          element.setAttribute(camelToKebab(key), `${theValue}`);
        });
      });

      return jLight(elements);
    }

    if (attribute === undefined) {
      const attrs = {};

      elements.forEach((element) => {
        [...element.attributes].forEach((attr) => {
          if (!attrs[attr]) {
            attrs[attr.name] = attr.value || true;
          }
        });
      });

      return attrs;
    }

    if (value === undefined) {
      let attr;

      elements.forEach((element) => {
        if (attr === undefined &amp;&amp; element.hasAttribute(attribute)) {
          attr = element.getAttribute(attribute) || true;
        }
      });

      return attr;
    }

    elements.forEach((element) => {
      element.setAttribute(attribute, `${value}`);
    });

    return jLight(elements);
  },

  /**
   * Removes the supplied attributes from the collections elements.
   *
   * @function
   * @tutorial removeAttr
   * @param {string|string[]} attribute The attribute or attributes to remove
   * @returns {jLight} jLight collection
   */
  removeAttr: (attribute) => {
    elements.forEach((element) => {
      if (Array.isArray(attribute)) {
        attribute.forEach((attr) => {
          element.removeAttribute(attr);
        });
      } else {
        element.removeAttribute(attribute);
      }
    });

    return jLight(elements);
  },

  /**
   * Gets or sets the text content of the collections elements.
   *
   * @function
   * @tutorial text
   * @param {string} [text] The text to supply to the function
   * @returns {jLight|string} jLight collection or the text content
   */
  text: (text) => getOrSetTextOrHtml('textContent', jLight(elements), text),

  /**
   * Gets or sets the HTML content of the collections elements.
   *
   * @function
   * @tutorial html
   * @param {string} [html] The html to supply to the function
   * @returns {jLight|string} jLight collection or the html content
   */
  html: (html) => getOrSetTextOrHtml('innerHTML', jLight(elements), html),

  /**
   * Gets or sets the collections elements values.
   *
   * @function
   * @tutorial val
   * @param {boolean|null|string|boolean[]|Function|iteratorCallback} [valueOrFunction]
   * The value to set the collections elements value to.
   * If a function is supplied its return value will be set as the value.
   * If the jLight element is an HTMLSelectElement with the multiple
   * attribute each option will be passed separately to the function.
   * In that case an array of booleans can be used to set the selected options.
   * @returns {jLight|boolean|string} jLight collection or the value
   */
  val: (valueOrFunction) => {
    if (valueOrFunction !== undefined) {
      const isFunction = typeof valueOrFunction === 'function';

      elements.forEach((theElement) => {
        const element = theElement;

        if (element.getAttribute('type') === 'checkbox') {
          element.checked = isFunction
            ? valueOrFunction()
            : !!valueOrFunction;
        } else if (element.tagName === 'SELECT' &amp;&amp; element.multiple) {
          [...element.querySelectorAll('option')].forEach((theOption, index) => {
            const option = theOption;
            let selected = false;

            if (Array.isArray(valueOrFunction)) {
              selected = !!valueOrFunction[index];
            } else if (isFunction) {
              selected = !!valueOrFunction(jLight(getElementsFromArgument(option)), index);
            } else {
              selected = !!valueOrFunction;
            }

            if (selected) {
              option.setAttribute('selected', 'selected');
            } else {
              option.removeAttribute('selected');
            }

            option.selected = selected;
          });
        } else {
          element.value = isFunction
            ? valueOrFunction()
            : valueOrFunction;
        }
      });

      return jLight(elements);
    }

    let value;

    elements.forEach((element) => {
      if (value === undefined) {
        if (element.getAttribute('type') === 'checkbox') {
          value = element.checked;
        } else if (element.tagName === 'SELECT' &amp;&amp; element.multiple) {
          value = [...element.querySelectorAll('option')]
            .map((option) => (option.selected ? option.value : null))
            .filter((theValue) => !!theValue);

          if (!value.length) {
            value = '';
          }
        } else {
          value = element.value;
        }
      }
    });

    return value;
  },

  /**
   * Gets or sets the jLight data of the collections elements.
   *
   * @function
   * @tutorial data
   * @param {string|Object.&lt;string, *>} [keyOrData] The key of the data value to get or set or
   * an object of data values to set.
   * @param {string|string[]} [value] The value to set the data at the supplied key to.
   * @returns {jLight|*} jLight collection
   */
  data: (keyOrData, value) => {
    if (typeof keyOrData === 'object' &amp;&amp; keyOrData !== null) {
      const newData = keyOrData;

      if (newData.jLightInternal) {
        delete newData.jLightInternal;
      }

      elements.forEach((element) => {
        updateJLightElementData(element, { ...newData });
      });

      return jLight(elements);
    }

    const key = kebabToCamel(keyOrData);

    if (key === 'jLightInternal') {
      return {};
    }

    if (value !== undefined) {
      elements.forEach((element) => {
        setJLightElementData(element, key, value);
      });

      return jLight(elements);
    }

    let data;

    elements.forEach((element) => {
      if (!data) {
        const jLightElementData = getJLightElementData(element);

        if (!keyOrData) {
          data = jLightElementData;

          Object.entries(element.dataset).forEach(([dataKey, dataValue]) => {
            if (!data[dataKey]) {
              if (!Number.isNaN(Number(dataValue))) {
                data[dataKey] = parseFloat(dataValue, 10);

                if (Number.isNaN(data[dataKey])) {
                  data[dataKey] = undefined;
                }
              } else {
                data[dataKey] = dataValue;
              }
            }
          });
        } else {
          data = jLightElementData[key];

          if (data === undefined) {
            data = element.getAttribute(`data-${keyOrData}`)
              || element.getAttribute(`data-${key}`);

            if (!data
              &amp;&amp; (element.hasAttribute(`data-${keyOrData}`)
                || element.hasAttribute(`data-${key}`))) {
              data = true;
            } else if (!Number.isNaN(Number(data))) {
              data = parseFloat(data, 10);

              if (Number.isNaN(data)) {
                data = undefined;
              }
            }
          }
        }
      }
    });

    if (data &amp;&amp; data.jLightInternal) {
      const newData = {};

      Object.entries(data).forEach(([dataKey, dataValue]) => {
        if (dataKey !== 'jLightInternal') {
          newData[dataKey] = dataValue;
        }
      });

      data = newData;
    }

    return data;
  },

  /**
   * @module Manipulation
   * @tutorial tut-manipulation
   */

  /**
   * Empties the collections elements HTML content.
   *
   * @function
   * @tutorial empty
   * @returns {jLight} jLight collection
   */
  empty: () => {
    elements.forEach((theElement) => {
      const element = theElement;

      element.innerHTML = '';
    });

    return jLight(elements);
  },

  /**
   * Clones the collection.
   *
   * @function
   * @tutorial clone
   * @param {boolean} [deep] Whether to apply deep cloning of the affected nodes (default: true)
   * @returns {jLight} jLight collection
   */
  clone: (deep = true) => jLight(elements.map((element) => element.cloneNode(deep))),

  /**
   * Adds elements to the collection.
   *
   * @function
   * @tutorial add
   * @param {jLight|string|HTMLElement|HTMLCollection|NodeList} $elements
   * The elements to apply the function to
   * @returns {jLight} jLight collection
   */
  add: ($elements) => {
    const theElements = getElementsFromArgument($elements);
    const addedElements = [];

    theElements.forEach((referenceElement) => {
      if (referenceElement &amp;&amp; !elements.includes(referenceElement)) {
        addedElements.push(referenceElement);
      }
    });

    return jLight([...elements, ...addedElements]);
  },

  /**
   * Removes elements from the collection.
   *
   * @function
   * @tutorial remove
   * @param {jLight|string|HTMLElement|HTMLCollection|NodeList} [$elements] The elements to remove
   * @param {boolean} [removeFromDom]
   * Whether the elements should also be removed from the DOM (default: true)
   * @returns {jLight|null} jLight collection or null
   */
  remove: ($elements, removeFromDom = true) => {
    if (!$elements) {
      elements.forEach((element) => {
        element.remove();
        removeJLightElementData(element);
      });

      return null;
    }

    const remainingElements = [];
    const theElements = getElementsFromArgument($elements);

    elements.forEach((element) => {
      let wasRemoved;

      theElements.forEach((referenceElement) => {
        if (element === referenceElement) {
          wasRemoved = true;

          if (removeFromDom) {
            element.remove();
            removeJLightElementData(element);
          }
        }
      });

      if (!wasRemoved) {
        remainingElements.push(element);
      }
    });

    return jLight(remainingElements);
  },

  /**
   * Prepends elements to the collections elements.
   *
   * @function
   * @tutorial prepend
   * @param {jLight|string|HTMLElement|HTMLCollection|NodeList} $elements
   * The elements to apply the function to
   * @returns {jLight} jLight collection
   */
  prepend: ($elements) => jLight(prependOrAppend('prepend', $elements, elements)),

  /**
   * Appends elements to the collections elements.
   *
   * @function
   * @tutorial append
   * @param {jLight|string|HTMLElement|HTMLCollection|NodeList} $elements
   * The elements to apply the function to
   * @returns {jLight} jLight collection
   */
  append: ($elements) => jLight(prependOrAppend('append', $elements, elements)),

  /**
   * Prepends the collections elements to elements.
   *
   * @function
   * @tutorial prependTo
   * @param {jLight|string|HTMLElement|HTMLCollection|NodeList} $elements
   * The elements to apply the function to
   * @returns {jLight} jLight collection
   */
  prependTo: ($elements) => jLight(prependToOrAppendTo('prepend', $elements, elements)),

  /**
   * Appends the collections elements to elements.
   *
   * @function
   * @tutorial appendTo
   * @param {jLight|string|HTMLElement|HTMLCollection|NodeList} $elements
   * The elements to apply the function to
   * @returns {jLight} jLight collection
   */
  appendTo: ($elements) => jLight(prependToOrAppendTo('append', $elements, elements)),

  /**
   * Inserts the collections elements before elements.
   *
   * @function
   * @tutorial insertBefore
   * @param {jLight|string|HTMLElement|HTMLCollection|NodeList} $elements
   * The elements to apply the function to
   * @returns {jLight} jLight collection
   */
  insertBefore: ($elements) => jLight(insertBeforeOrInsertAfter('beforeBegin', $elements, elements, 'insert')),

  /**
   * Inserts the collections elements after elements.
   *
   * @function
   * @tutorial insertAfter
   * @param {jLight|string|HTMLElement|HTMLCollection|NodeList} $elements
   * The elements to apply the function to
   * @returns {jLight} jLight collection
   */
  insertAfter: ($elements) => jLight(insertBeforeOrInsertAfter('afterEnd', $elements, elements, 'insert')),

  /**
   * Inserts elements before the collections elements.
   *
   * @function
   * @tutorial before
   * @param {jLight|string|HTMLElement|HTMLCollection|NodeList} $elements
   * The elements to apply the function to
   * @returns {jLight} jLight collection
   */
  before: ($elements) => jLight(insertBeforeOrInsertAfter('beforeBegin', $elements, elements)),

  /**
   * Inserts elements after the collections elements.
   *
   * @function
   * @tutorial after
   * @param {jLight|string|HTMLElement|HTMLCollection|NodeList} $elements
   * The elements to apply the function to
   * @returns {jLight} jLight collection
   */
  after: ($elements) => jLight(insertBeforeOrInsertAfter('afterEnd', $elements, elements)),

  /**
   * Wraps the collections elements in elements.
   *
   * @function
   * @tutorial wrap
   * @param {jLight|string|HTMLElement|HTMLCollection|NodeList} $elements
   * The elements to apply the function to
   * @returns {jLight} jLight collection
   */
  wrap: ($elements) => {
    const theElements = getElementsFromArgument($elements);

    elements.forEach((element) => {
      theElements.forEach((referenceElement) => {
        if (element !== referenceElement) {
          element.parentNode.insertBefore(referenceElement, element);
          referenceElement.appendChild(element);
        }
      });
    });

    return jLight(elements);
  },

  /**
   * @module Selection
   * @tutorial tut-selection
   */

  /**
   * Gets the element at the supplied index from the collection.
   *
   * @function
   * @tutorial get
   * @param {number} index The index to supply to the function
   * @returns {HTMLElement|undefined} The element or null
   */
  get: (index) => elements[index],

  /**
   * Gets the jLight element at the supplied index from the collection.
   *
   * @function
   * @tutorial eq
   * @param {number} index The index to supply to the function
   * @returns {jLight} jLight collection
   */
  eq: (index) => jLight(elements[index] ? [elements[index]] : []),

  /**
   * Gets the first jLight element from the collection.
   *
   * @function
   * @tutorial first
   * @returns {jLight} jLight collection
   */
  first: () => jLight(elements[0] ? [elements[0]] : []),

  /**
   * Gets the last jLight element from the collection.
   *
   * @function
   * @tutorial last
   * @returns {jLight} jLight collection
   */
  last: () => jLight(elements.length ? [elements[elements.length - 1]] : []),

  /**
   * Gets a jLight collection from the collections parent elements.
   *
   * @function
   * @tutorial parent
   * @returns {jLight} jLight collection
   */
  parent: () => jLight(getParents(elements)),

  /**
   * Gets a jLight collection from all the collections parent elements.
   *
   * @function
   * @tutorial parents
   * @returns {jLight} jLight collection
   */
  parents: () => jLight(getParents(elements, true)),

  /**
   * Gets a jLight collection from the collections children elements.
   *
   * @function
   * @tutorial children
   * @returns {jLight} jLight collection
   */
  children: () => jLight(elements.reduce(
    (children, element) => [...children, ...element.children], [],
  )),

  /**
   * Gets a jLight collection from the collections sibling elements.
   *
   * @function
   * @tutorial siblings
   * @returns {jLight} jLight collection
   */
  siblings: () => {
    const siblings = [];

    elements.forEach((element) => {
      const { parentElement } = element;

      [...parentElement.children].forEach((child) => {
        if (!siblings.includes(child) &amp;&amp; !elements.includes(child)) {
          siblings.push(child);
        }
      });
    });

    return jLight(siblings);
  },

  /**
   * Gets a jLight collection from the collections previous sibling elements.
   *
   * @function
   * @tutorial prev
   * @param {string} [selector] The selector to use for matching elements
   * @returns {jLight} jLight collection
   */
  prev: (selector) => jLight(getPrevOrNextElements('previousElementSibling', selector, elements)),

  /**
   * Gets a jLight collection from the collections next sibling elements.
   *
   * @function
   * @tutorial next
   * @param {string} [selector] The selector to use for matching elements
   * @returns {jLight} jLight collection
   */
  next: (selector) => jLight(getPrevOrNextElements('nextElementSibling', selector, elements)),

  /**
   * Gets a jLight collection from all the collections parent elements matching the selector.
   *
   * @function
   * @tutorial closest
   * @param {string} [selector] The selector to use for matching elements
   * @returns {jLight} jLight collection
   */
  closest: (selector) => {
    const closestElements = [];

    elements.forEach((element) => {
      const closest = getClosestMatchingElement(element, selector);

      if (closest &amp;&amp; !closestElements.includes(closest)) {
        closestElements.push(closest);
      }
    });

    return jLight(closestElements);
  },

  /**
   * Gets a jLight collection from the collections elements which are not part of elements.
   *
   * @function
   * @tutorial not
   * @param {jLight|string|HTMLElement|HTMLCollection|NodeList} $elements
   * The elements to apply the function to
   * @returns {jLight} jLight collection
   */
  not: ($elements) => {
    const selectedElements = getElementsFromArgument($elements);

    const remainingElements = elements.filter((element) => {
      let keepElement = true;

      selectedElements.forEach((selectedElement) => {
        if (keepElement &amp;&amp; selectedElement === element) {
          keepElement = false;
        }
      });

      return keepElement;
    });

    return jLight(remainingElements);
  },

  /**
   * Gets a jLight collection from the collections elements which contain elements.
   *
   * @function
   * @tutorial has
   * @param {jLight|string|HTMLElement|HTMLCollection|NodeList} $elements
   * The elements to apply the function to
   * @returns {jLight} jLight collection
   */
  has: ($elements) => {
    const selectedElements = getElementsFromArgument($elements);

    const filteredElements = elements.filter((element) => {
      let hasElement = false;

      selectedElements.forEach((selectedElement) => {
        if (!hasElement
          &amp;&amp; element !== selectedElement
          &amp;&amp; element.contains(selectedElement)) {
          hasElement = true;
        }
      });

      return hasElement;
    });

    return jLight(filteredElements);
  },

  /**
   * @module ArrayLike
   * @tutorial tut-array-like
   */

  /**
   * Gets a filtered jLight collection based on the input.
   *
   * @function
   * @tutorial filter
   * @param {string|iteratorCallback} callbackOrSelector
   * The selector to filter the collection by or a custom
   * function to decide which elements to filter out
   * @returns {jLight} jLight collection
   */
  filter: (callbackOrSelector) => {
    const filteredElements = [];

    elements.forEach((element, index) => {
      if (typeof callbackOrSelector === 'function') {
        if (callbackOrSelector(jLight([element]), index)) {
          filteredElements.push(element);
        }
      } else if (element.matches(callbackOrSelector)) {
        filteredElements.push(element);
      }
    });

    return jLight(filteredElements);
  },

  /**
   * Runs a function on each of the collections elements.
   *
   * @function
   * @tutorial forEach
   * @param {iteratorCallback} callback The function to apply to each element
   * @returns {jLight} jLight collection
   */
  forEach: (callback) => {
    elements.forEach((element, index) => {
      callback(jLight([element]), index);
    });

    return jLight(elements);
  },

  /**
   * [DEPRECATED] Runs a function on each of the collections elements.
   *
   * @deprecated
   * Will be removed in version 1.2.0,
   * use [jLight]{@link jLight}.[forEach]{@link module:ArrayLike~forEach} instead
   * @function
   * @tutorial each
   * @param {iteratorCallback} callback The function to apply to each element
   * @returns {jLight} jLight collection
   */
  each: (callback) => {
    // eslint-disable-next-line no-console
    console.warn('jLight.each is deprecated an will be removed in version 1.2.0, use jLight.forEach instead');

    return jLight(elements).forEach(callback);
  },

  /**
   * Slices the collection.
   *
   * @function
   * @tutorial slice
   * @param {number} [start] The index to start the slicing
   * @param {number} [end] The index to end the slicing
   * @returns {jLight} jLight collection
   */
  slice: (start, end) => jLight(elements.slice(start, end)),

  /**
   * Splices the collection
   *
   * @function
   * @tutorial splice
   * @param {number} start The index to start the splicing
   * @param {number} [deleteCount] The count of elements to delete
   * @returns {jLight} jLight collection
   */
  splice: (start, deleteCount) => jLight(elements.splice(start, deleteCount)),

  /**
   * Pushes elements to the collection.
   *
   * @function
   * @tutorial push
   * @param {...(jLight|string|HTMLElement|HTMLCollection|NodeList)} args
   * The elements to apply to the function.
   * @returns {number} The collections new length
   */
  push: (...args) => {
    args.forEach((arg) => {
      elements.push(...getElementsFromArgument(arg));
    });

    return elements.length;
  },

  /**
   * Pops the last element from the collection.
   *
   * @function
   * @tutorial pop
   * @returns {jLight} jLight collection
   */
  pop: () => jLight([elements.pop()]),

  /**
   * Reverses a collection.
   *
   * @function
   * @tutorial reverse
   * @returns {jLight} jLight collection
   */
  reverse: () => jLight(elements.reverse()),

  /**
   * Shifts a collection.
   *
   * @function
   * @tutorial shift
   * @returns {jLight} jLight collection
   */
  shift: () => jLight([elements.shift()]),

  /**
   * Unshifts a collection.
   *
   * @function
   * @tutorial unshift
   * @param {...(jLight|string|HTMLElement|HTMLCollection|NodeList)} args
   * The elements to apply to the function.
   * @returns {number} The collections new length
   */
  unshift: (...args) => {
    const theElements = [];

    args.forEach((arg) => {
      theElements.push(...getElementsFromArgument(arg));
    });

    elements.unshift(...theElements.reverse());

    return elements.length;
  },

  /**
   * Sorts a collection.
   *
   * @function
   * @tutorial sort
   * @param {compareCallback} compareFunction The function used for sorting
   * @returns {jLight} jLight collection
   */
  sort: (compareFunction = noop) => jLight(
    elements.sort((element1, element2) => compareFunction(jLight([element1]), jLight([element2]))),
  ),

  /**
   * Reduces a collection.
   *
   * @function
   * @tutorial reduce
   * @param {reduceInnerCallback} callback The function used for reduction
   * @param {*} [initialValue] The initial value used for reduction
   * @returns {*} The reduction result
   */
  reduce: (callback, initialValue) => elements.reduce(
    (accumulator, element, index) => callback(accumulator, jLight([element]), index),
    initialValue,
  ),

  /**
   * Maps a collection.
   *
   * @function
   * @tutorial map
   * @param {mapInnerCallback} callback The function used for mapping
   * @returns {jLight} jLight collection
   */
  map: (callback) => jLight(elements.map((element, index) => {
    const argument = callback(jLight([element]), index);

    return getElementsFromArgument(argument)[0];
  })),

  /**
   * Concats a collection with other collections.
   *
   * @function
   * @tutorial concat
   * @param {...(jLight|string|HTMLElement|HTMLCollection|NodeList|
   * Array.&lt;jLight|string|HTMLElement|HTMLCollection|NodeList>)} args
   * The elements to apply to the function.
   * @returns {jLight} jLight collection
   */
  concat: (...args) => {
    const theElements = [];

    args.forEach((arg) => {
      if (Array.isArray(arg)) {
        arg.forEach((a) => {
          theElements.push(...getElementsFromArgument(a));
        });
      } else {
        theElements.push(...getElementsFromArgument(arg));
      }
    });

    return jLight(elements.concat(theElements));
  },

  /**
   * Whether the collections elements include at least one of elements.
   *
   * @function
   * @tutorial includes
   * @param {jLight|string|HTMLElement|HTMLCollection|NodeList} $elements
   * The elements to supply to the function
   * @returns {boolean} If the conditon is met
   */
  includes: ($elements) => {
    const theElements = getElementsFromArgument($elements);
    let includes;

    elements.forEach((element) => {
      if (!includes) {
        theElements.forEach((referenceElement) => {
          if (!includes) {
            includes = element === referenceElement;
          }
        });
      }
    });

    return includes;
  },

  /**
   * Whether at least one of the collections elements meets the conditon.
   *
   * @function
   * @tutorial some
   * @param {iteratorBooleanCallback} callback
   * The elements to supply to the function
   * @returns {boolean} If the conditon is met
   */
  some: (callback) => {
    let isMet;

    elements.forEach((element, index) => {
      if (!isMet &amp;&amp; callback(jLight([element]), index)) {
        isMet = true;
      }
    });

    return isMet;
  },

  /**
   * Whether every one of the collections elements meets the conditon.
   *
   * @function
   * @tutorial every
   * @param {iteratorBooleanCallback} callback
   * The elements to supply to the function
   * @returns {boolean} If the conditon is met
   */
  every: (callback) => {
    let matchCount = 0;

    elements.forEach((element, index) => {
      if (callback(jLight([element]), index)) {
        matchCount += 1;
      }
    });

    return matchCount === elements.length;
  },

  /**
   * Gets the given elements index inside the collection.
   *
   * @function
   * @tutorial indexOf
   * @param {jLight|string|HTMLElement|HTMLCollection|NodeList} $elements
   * The elements to supply to the function
   * @returns {number} The resulting number
   */
  indexOf: ($elements) => indexOfOfLastIndexOf('indexOf', elements, $elements),

  /**
   * Gets the given elements last index inside the collection.
   *
   * @function
   * @tutorial lastIndexOf
   * @param {jLight|string|HTMLElement|HTMLCollection|NodeList} $elements
   * The elements to supply to the function
   * @returns {number} The resulting number
   */
  lastIndexOf: ($elements) => indexOfOfLastIndexOf('lastIndexOf', elements, $elements),

  /**
   * Gets a jLight collection from the collections children elements matching the selector.
   *
   * @function
   * @tutorial find
   * @param {string} [selector] The selector to use for matching elements
   * @returns {jLight} jLight collection
   */
  find: (selector) => {
    let foundElements = [];

    elements.forEach((element) => {
      foundElements = [...foundElements, ...element.querySelectorAll(selector)];
    });

    return jLight(foundElements);
  },

  /**
   * @module Dimensions
   * @tutorial tut-dimensions
   */

  /**
   * Gets or sets the width of the collections elements.
   *
   * @function
   * @tutorial width
   * @param {number} [width] The width to supply to the function
   * @returns {jLight|number} jLight collection or the width
   */
  width: (width) => getOrSetDimension('width', jLight(elements), width),

  /**
   * Gets or sets the height of the collections elements.
   *
   * @function
   * @tutorial height
   * @param {number} [height] The height to supply to the function
   * @returns {jLight|number} jLight collection or the height
   */
  height: (height) => getOrSetDimension('height', jLight(elements), height),

  /**
   * Gets the inner width of the collections elements.
   *
   * @function
   * @tutorial innerWidth
   * @returns {number} The dimension value
   */
  innerWidth: () => getDimension('innerWidth', elements),

  /**
   * Gets the inner height of the collections elements.
   *
   * @function
   * @tutorial innerHeight
   * @returns {number} The dimension value
   */
  innerHeight: () => getDimension('innerHeight', elements),

  /**
   * Gets the outer width of the collections elements.
   *
   * @function
   * @tutorial outerWidth
   * @param {boolean} [includeMargins] Whether to include the elements margins (default: false)
   * @returns {number} The dimension value
   */
  outerWidth: (includeMargins) => getDimension('outerWidth', elements, includeMargins),

  /**
   * Gets the outer height of the collections elements.
   *
   * @function
   * @tutorial outerHeight
   * @param {boolean} [includeMargins] Whether to include the elements margins (default: false)
   * @returns {number} The dimension value
   */
  outerHeight: (includeMargins) => getDimension('outerHeight', elements, includeMargins),

  /**
   * Gets the scroll width of the collections elements.
   *
   * @function
   * @tutorial scrollWidth
   * @returns {number} The dimension value
   */
  scrollWidth: () => getScrollWidthOrScrollHeight('scrollWidth', elements),

  /**
   * Gets the scroll height of the collections elements.
   *
   * @function
   * @tutorial scrollHeight
   * @returns {number} The dimension value
   */
  scrollHeight: () => getScrollWidthOrScrollHeight('scrollHeight', elements),

  /**
   * Gets or sets the scrollTop of the collections elements.
   *
   * @function
   * @tutorial scrollTop
   * @param {number} [value] The value to supply to the function
   * @returns {jLight|number} jLight collection or the value
   */
  scrollTop: (value) => getOrSetScrollTopOrScrollLeft('scrollTop', value, jLight(elements)),

  /**
   * Gets or sets the scrollLeft of the collections elements.
   *
   * @function
   * @tutorial scrollLeft
   * @param {number} [value] The value to supply to the function
   * @returns {jLight|number} jLight collection or the value
   */
  scrollLeft: (value) => getOrSetScrollTopOrScrollLeft('scrollLeft', value, jLight(elements)),

  /**
   * Gets or sets the collections elements offset.
   *
   * @function
   * @tutorial offset
   * @param {boolean|{top: number, left: number}} [value]
   * The value to set the elements offset to or if the
   * returned offset should be relative to the viewport
   * @param {boolean} [relativeToViewport]
   * Whether the offset should be set relative to the viewport (default: false)
   * @returns {jLight|{top: number, left: number}} jLight collection or elements offset
   */
  offset: (value, relativeToViewport) => {
    if (value &amp;&amp; typeof value !== 'boolean') {
      const { top, left } = value;
      const topIsPixelUnit = typeof top === 'number' || (top &amp;&amp; top.indexOf('px') > -1);
      const leftIsPixelUnit = typeof left === 'number' || (left &amp;&amp; left.indexOf('px') > -1);
      const offsetTop = relativeToViewport ? window.pageYOffset : 0;
      const offsetLeft = relativeToViewport ? window.pageXOffset : 0;
      const unitTop = topIsPixelUnit ? 'px' : '';
      const unitLeft = leftIsPixelUnit ? 'px' : '';

      elements.forEach((theElement) => {
        const element = theElement;
        const computedStyles = window.getComputedStyle(element);

        element.style.top = (top || top === 0)
          ? `${topIsPixelUnit ? parseFloat(top, 10) + offsetTop : top}${unitTop}`
          : `${parseFloat(computedStyles.getPropertyValue('top'), 10)}${offsetTop || ''}${unitTop}`;

        element.style.left = (left || left === 0)
          ? `${leftIsPixelUnit ? parseFloat(left, 10) + offsetLeft : top}${unitLeft}`
          : `${parseFloat(computedStyles.getPropertyValue('left'), 10)}${offsetLeft || ''}${unitLeft}`;
      });

      return jLight(elements);
    }

    let offset;

    elements.forEach((element) => {
      const boundingBox = element.getBoundingClientRect();

      if (offset === undefined) {
        offset = boundingBox;
      }
    });

    const relative = typeof value === 'boolean' &amp;&amp; value;

    return {
      top: (offset.top || 0) + (relative ? window.pageYOffset : 0),
      left: (offset.left || 0) + (relative ? window.pageXOffset : 0),
    };
  },

  /**
   * @module Animation
   * @tutorial tut-animation
   */

  /**
   * Animates the given properties to the given values on the collections elements.
   *
   * @function
   * @tutorial animate
   * @param {Object.&lt;string, string>} [properties] The css properties and values to animate
   * @param {number} [duration] The duration for the animation in ms (default: 300)
   * @param {Function} [callback]
   * The function to run after the animation is complete (default: noop)
   * @param {string} [easing] Which type of css easing to use for the animation (default: 'ease')
   * @returns {jLight} jLight collection
   */
  animate: (properties, duration = 300, callback = noop, easing = 'ease') => {
    const animationId = getUpdateAnimationId(elements[0]);

    elements.forEach((theElement, elementIndex) => {
      const element = theElement;
      let transition = '';

      Object.entries(properties).forEach(([key, value], index) => {
        const theKey = camelToKebab(key);

        transition += `${index === 0 ? '' : ','}${theKey} ${duration}ms ${easing}`;

        if (element.style[key] === undefined) {
          element.style[key] = getElementStyle(element, key);
        }

        setTimeout(() => {
          element.style[key] = value;
        }, 0);
      });

      updateJLightElementData(element, {
        jLightInternal: {
          ...(getJLightElementData(element).jLightInternal || {}),
          animatedProperties: Object.keys(properties),
        },
      });

      element.style.transition = transition;

      setTimeout(() => {
        if (getJLightElementData(elements[0]).jLightInternal.currentAnimation !== animationId) {
          return;
        }

        if (elementIndex === elements.length - 1) {
          elements.forEach((elementToReset) => {
            const theElementToReset = elementToReset;

            theElementToReset.style.transition = '';
          });

          callback();
        }
      }, duration);
    });

    return jLight(elements);
  },

  /**
   * Scrolls the collections elements to elements.
   *
   * @function
   * @tutorial scrollTo
   * @param {jLight|string|HTMLElement|HTMLCollection|NodeList} $elements
   * The elements to scroll the collections elements to
   * @param {number} [duration] The duration of the scroll animation in ms (default: 300)
   * @param {{x: number, y: number}|{}} [offset] The offset for the target position
   * @param {Function} [callback] The function to run after the scrolling is complete
   * @returns {jLight} jLight collection
   */
  scrollTo: ($elements, duration = 300, offset = {}, callback) => {
    const theOffset = {
      x: 0,
      y: 0,
      ...offset,
    };

    const [element] = elements;
    const targets = getElementsFromArgument($elements);
    const boundingBox = element.getBoundingClientRect();
    const left = targets[0].offsetLeft
      - boundingBox.left
      - window.pageXOffset;
    const top = targets[0].offsetTop
      - boundingBox.top
      - window.pageYOffset;
    const innerWidth = Math.max(element.clientWidth, element.offsetWidth);
    const innerHeight = Math.max(element.clientHeight, element.offsetHeight);
    const { scrollWidth, scrollHeight } = element;
    const startPositionX = element.scrollLeft;
    const startPositionY = element.scrollTop;
    const targetX = scrollWidth - left &lt; innerWidth
      ? scrollWidth - innerWidth - theOffset.x
      : left - theOffset.x;
    const targetY = scrollHeight - top &lt; innerHeight
      ? scrollHeight - innerHeight - theOffset.y
      : top - theOffset.y;
    const differenceX = targetX - startPositionX;
    const differenceY = targetY - startPositionY;

    doEasing(duration, (percent) => {
      element.scrollLeft = startPositionX + differenceX * percent;
      element.scrollTop = startPositionY + differenceY * percent;
    }, callback);

    return jLight(elements);
  },

  /**
   * Stops all running animations on the collections elements.
   *
   * @function
   * @tutorial stop
   * @returns {jLight} jLight collection
   */
  stop: () => {
    elements.forEach((theElement) => {
      const element = theElement;
      const jLightInternalData = getJLightElementData(element).jLightInternal;
      const animatedProperties = jLightInternalData.animatedProperties
        || [];

      updateJLightElementData(element, {
        jLightInternal: {
          ...jLightInternalData,
          currentAnimation: null,
        },
      });

      animatedProperties.forEach((key) => {
        element.style[key] = getElementStyle(element, camelToKebab(key));
      });

      element.style.transition = '';
    });

    return jLight(elements);
  },

  /**
   * Fades the collections elements in.
   *
   * @function
   * @tutorial fadeIn
   * @param {number} [duration] The duration for the animation in ms (default: 300)
   * @param {Function} [callback]
   * The function to run after the animation is complete (default: noop)
   * @param {string} [easing] Which type of css easing to use for the animation (default: 'ease')
   * @param {string} [type]
   * The css display type to apply to the collections elements
   * @returns {jLight} jLight collection
   */
  fadeIn: (duration, callback, easing, type) => {
    elements.forEach((theElement) => {
      const element = theElement;
      const { display } = getJLightElementData(element).jLightInternal;
      const computedDisplay = getElementStyle(element, 'display');

      if (computedDisplay !== 'none') {
        updateJLightDisplayData(element, computedDisplay);
      }

      getUpdateAnimationId(element);
      element.style.opacity = 0;

      element.style.display = type
      || display
      || (computedDisplay !== 'none' ? computedDisplay : false)
      || 'block';

      setTimeout(() => {
        jLight([element]).animate({ opacity: 1 }, duration, callback, easing);
      }, 1);
    });

    return jLight(elements);
  },

  /**
   * Fades the collections elements out.
   *
   * @function
   * @tutorial fadeOut
   * @param {number} [duration] The duration for the animation in ms (default: 300)
   * @param {Function} [callback]
   * The function to run after the animation is complete (default: noop)
   * @param {string} [easing] Which type of css easing to use for the animation (default: 'ease')
   * @returns {jLight} jLight collection
   */
  fadeOut: (duration, callback, easing) => {
    elements.forEach((theElement) => {
      const element = theElement;
      const computedDisplay = getElementStyle(element, 'display');

      if (computedDisplay !== 'none') {
        updateJLightDisplayData(element, computedDisplay);
      }

      setTimeout(() => {
        jLight([element]).animate({ opacity: 0 }, duration, () => {
          element.style.display = 'none';

          if (callback) {
            callback();
          }
        }, easing);
      }, 1);
    });

    return jLight(elements);
  },

  /**
   * Toggles the display state of the collections elements by fading.
   *
   * @function
   * @tutorial fadeToggle
   * @param {number} [duration] The duration for the animation in ms (default: 300)
   * @param {Function} [callback]
   * The function to run after the animation is complete (default: noop)
   * @param {string} [easing] Which type of css easing to use for the animation (default: 'ease')
   * @param {string} [type]
   * The css display type to apply to the collections elements
   * @param {boolean} [force] Force whether to fade in or out
   * @returns {jLight} jLight collection
   */
  fadeToggle: (duration, callback, easing, type, force) => {
    const forceDefined = force !== undefined;
    const forceFadeIn = forceDefined &amp;&amp; force;
    const forceFadeOut = forceDefined &amp;&amp; !force;

    elements.forEach((theElement) => {
      const element = theElement;

      if (forceFadeIn || (getElementStyle(element, 'display') === 'none' &amp;&amp; !forceFadeOut)) {
        jLight([element]).fadeIn(duration, callback, easing, type);
      } else {
        jLight([element]).fadeOut(duration, callback, easing);
      }
    });

    return jLight(elements);
  },

  /**
   * Slides the collections elements down.
   *
   * @function
   * @tutorial slideDown
   * @param {number} [duration] The duration for the animation in ms (default: 300)
   * @param {Function} [callback]
   * The function to run after the animation is complete (default: noop)
   * @param {string} [easing] Which type of css easing to use for the animation (default: 'ease')
   * @param {string} [type]
   * The css display type to apply to the collections elements
   * @param {string} [height] The css height value to end the sliding animation
   * @returns {jLight} jLight collection
   */
  slideDown: (duration, callback, easing, type, height) => {
    jLight(elements).stop();

    elements.forEach((theElement) => {
      const element = theElement;
      const startHeight = Math.max(element.clientHeight, element.offsetHeight);
      const computedStyles = window.getComputedStyle(element);
      const computedDisplay = computedStyles.getPropertyValue('display');
      const computedMinHeight = computedStyles.getPropertyValue('min-height');
      const paddingTop = parseFloat(computedStyles.getPropertyValue('padding-top'), 10);
      const paddingBottom = parseFloat(computedStyles.getPropertyValue('padding-bottom'), 10);
      const borderTop = computedStyles.getPropertyValue('border-top');
      const borderBottom = computedStyles.getPropertyValue('border-bottom');
      const borderTopParsed = parseFloat(borderTop, 10);
      const borderBottomParsed = parseFloat(borderBottom, 10);
      const borderTopStyle = borderTop.replace(`${borderTopParsed}px`, '');
      const borderBottomStyle = borderBottom.replace(`${borderBottomParsed}px`, '');
      const { display } = getJLightElementData(element).jLightInternal;

      if (computedDisplay !== 'none') {
        updateJLightDisplayData(element, computedDisplay);
      }

      Object.assign(element.style, {
        overflow: 'hidden',
        visibility: 'hidden',
        minHeight: '',
      });

      element.style.height = height
        || (computedMinHeight !== '0px' ? computedMinHeight : false)
        || '';

      element.style.display = type
        || display
        || (computedDisplay !== 'none' ? computedDisplay : false)
        || 'block';

      const targetHeight = Math.max(
        element.clientHeight,
        element.offsetHeight,
        parseFloat(computedMinHeight, 10),
      ) - borderTopParsed
        - borderBottomParsed;

      Object.assign(element.style, {
        height: `${startHeight}px`,
        minHeight: 'revert',
        visibility: '',
        paddingTop: 0,
        paddingBottom: 0,
        borderTop: `0px${borderTopStyle}`,
        borderBottom: `0px${borderBottomStyle}`,
      });

      setTimeout(() => {
        jLight([element]).animate({
          height: `${targetHeight}px`,
          paddingTop: `${paddingTop}px`,
          paddingBottom: `${paddingBottom}px`,
          borderTop: `${borderTopParsed}px${borderTopStyle}`,
          borderBottom: `${borderBottomParsed}px${borderBottomStyle}`,
        }, duration, () => {
          Object.assign(element.style, {
            height: height || '',
            minHeight: '',
            paddingTop: '',
            paddingBottom: '',
            overflow: '',
          });

          if (callback) {
            callback();
          }
        }, easing);
      }, 15);
    });

    return jLight(elements);
  },

  /**
   * Slides the collections elements up.
   *
   * @function
   * @tutorial slideUp
   * @param {number} [duration] The duration for the animation in ms (default: 300)
   * @param {Function} [callback]
   * The function to run after the animation is complete (default: noop)
   * @param {string} [easing] Which type of css easing to use for the animation (default: 'ease')
   * @returns {jLight} jLight collection
   */
  slideUp: (duration, callback, easing) => {
    jLight(elements).stop();

    elements.forEach((theElement) => {
      const element = theElement;
      const computedStyles = window.getComputedStyle(element);
      const computedDisplay = computedStyles.getPropertyValue('display');
      const borderTop = computedStyles.getPropertyValue('border-top');
      const borderBottom = computedStyles.getPropertyValue('border-bottom');
      const borderTopParsed = parseFloat(borderTop, 10);
      const borderBottomParsed = parseFloat(borderBottom, 10);

      const startHeight = Math.max(
        element.clientHeight,
        element.offsetHeight,
      ) - borderTopParsed
        - borderBottomParsed;

      if (computedDisplay !== 'none') {
        updateJLightDisplayData(element, computedDisplay);
      }

      Object.assign(element.style, {
        overflow: 'hidden',
        height: `${startHeight}px`,
        minHeight: 'auto',
        paddingTop: computedStyles.getPropertyValue('padding-top'),
        paddingBottom: computedStyles.getPropertyValue('padding-bottom'),
        borderTop,
        borderBottom,
      });

      setTimeout(() => {
        jLight([element]).animate({
          height: 0,
          paddingTop: 0,
          paddingBottom: 0,
          borderTop: `0px${borderTop.replace(`${borderTopParsed}px`, '')}`,
          borderBottom: `0px${borderBottom.replace(`${borderBottomParsed}px`, '')}`,
        }, duration, () => {
          Object.assign(element.style, {
            display: 'none',
            height: '',
            overflow: '',
            minHeight: '',
            paddingTop: '',
            paddingBottom: '',
            borderTop: '',
            borderBottom: '',
          });

          if (callback) {
            callback();
          }
        }, easing);
      }, 1);
    });

    return jLight(elements);
  },

  /**
   * Toggles the display state of the collections elements by sliding.
   *
   * @function
   * @tutorial slideToggle
   * @param {number} [duration] The duration for the animation in ms (default: 300)
   * @param {Function} [callback]
   * The function to run after the animation is complete (default: noop)
   * @param {string} [easing] Which type of css easing to use for the animation (default: 'ease')
   * @param {string} [type]
   * The css display type to apply to the collections elements
   * @param {string} [height] The css height value to end the sliding animation
   * @param {boolean} [force] Force whether to slide down or up
   * @returns {jLight} jLight collection
   */
  slideToggle: (duration, callback, easing, type, height, force) => {
    const forceDefined = force !== undefined;
    const forceSlideDown = forceDefined &amp;&amp; force;
    const forceSlideUp = forceDefined &amp;&amp; !force;

    elements.forEach((theElement) => {
      const element = theElement;

      if (forceSlideDown || (getElementStyle(element, 'display') === 'none' &amp;&amp; !forceSlideUp)) {
        jLight([element]).slideDown(duration, callback, easing, type, height);
      } else {
        jLight([element]).slideUp(duration, callback, easing);
      }
    });

    return jLight(elements);
  },

  /**
   * @module Utility
   * @tutorial tut-utility
   */

  /**
   * Whether a property of an element of the collection is true
   * or if an element of the collection is part of another set.
   *
   * @function
   * @tutorial is
   * @param {jLight|string|HTMLElement|HTMLCollection|NodeList} propertyOrElements
   * The property or set to compare the collections elements to
   * @returns {boolean} If the property is set on one of the collections elements or
   * at least on of the elements is contained in the supplied elements
   */
  is: (propertyOrElements) => {
    let is;

    if (typeof propertyOrElements === 'string') {
      elements.forEach((element) => {
        if (is === undefined) {
          is = element[propertyOrElements];
        }
      });
    } else {
      const theElements = getElementsFromArgument(propertyOrElements);

      theElements.forEach((theElement) => {
        if (elements.includes(theElement)) {
          if (is === undefined) {
            is = true;
          }
        }
      });
    }

    return !!is;
  },

  /**
   * Whether the collections elements contain at least one of elements.
   *
   * @function
   * @tutorial contains
   * @param {jLight|string|HTMLElement|HTMLCollection|NodeList} $elements
   * The elements to supply to the function
   * @returns {boolean} If the conditon is met
   */
  contains: ($elements) => {
    const theElements = getElementsFromArgument($elements);
    let contains;

    elements.forEach((element) => {
      if (!contains) {
        theElements.forEach((referenceElement) => {
          if (!contains) {
            contains = element.contains(referenceElement);
          }
        });
      }
    });

    return contains;
  },

  /**
   * Checks if the collections first element is in view or runs a function if that is the case.
   *
   * @function
   * @tutorial inView
   * @param {Function|{top: number, bottom: number, left: number, right: number}} [offsetOrCallback]
   * The offset used for determining if the element is in view
   * or the function to run each time that is the case
   * @param {Function|
   *  {scrollTimer: ?number, isInView: ?Function, onEnter: ?Function, onExit: ?Function}
   * } [callbackOrOptions]
   * The function to run each time the element is in view
   * or a custom options object to define the functions behavior
   * (defaults: { scrollTimer: 100, isInView: noop, onEnter: noop, onExit: noop })
   * @returns {jLight|boolean} jLight collection or whether the collections first element is in view
   */
  inView: (offsetOrCallback, callbackOrOptions) => {
    let offset = {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0,
    };

    if (typeof offsetOrCallback === 'object' &amp;&amp; offsetOrCallback) {
      offset = {
        ...offset,
        ...offsetOrCallback,
      };
    }

    const offsetOrCallbackIsFunction = typeof offsetOrCallback === 'function';
    const callbackOrOptionsIsFunction = typeof callbackOrOptions === 'function';

    if (!offsetOrCallbackIsFunction
      &amp;&amp; !callbackOrOptionsIsFunction
      &amp;&amp; typeof callbackOrOptions !== 'object'
      &amp;&amp; callbackOrOptions !== null) {
      return isInView(elements[0].getBoundingClientRect(), offset);
    }

    const options = callbackOrOptions || {};
    const scrollTimer = options.scrollTimer || 100;
    let scrollTimeout;

    window.addEventListener('scroll', () => {
      if (scrollTimeout) {
        clearTimeout(scrollTimeout);
      }

      scrollTimeout = setTimeout(() => {
        const isElementInView = isInView(elements[0].getBoundingClientRect(), offset);

        if (isElementInView &amp;&amp; options.isInView) {
          options.isInView();
        }

        if (isElementInView &amp;&amp; !getJLightElementData(elements[0]).isInView) {
          if (options.onEnter) {
            options.onEnter();
          } else if (offsetOrCallbackIsFunction) {
            offsetOrCallback();
          } else if (callbackOrOptionsIsFunction) {
            callbackOrOptions();
          }

          updateJLightElementData(elements[0], {
            isInView: true,
          });

          return;
        }

        if (!isElementInView &amp;&amp; getJLightElementData(elements[0]).isInView) {
          if (options.onExit) {
            options.onExit();
          }

          updateJLightElementData(elements[0], {
            isInView: false,
          });
        }
      }, scrollTimer);
    });

    return jLight(elements);
  },

  /**
   * Delays code execution.
   *
   * @function
   * @tutorial delay
   * @param {number} [delay] The duration to delay the code execution for
   * @returns {Promise} The corresponding promise
   */
  delay: (delay) => new Promise((resolve) => setTimeout(resolve, delay)),

  /**
   * Calls the supplied function with the supplied arguments if the given condition is met.
   *
   * @function
   * @tutorial when
   * @param {boolean|Function} condition The condition to check for.
   * If a function is supplied its return value will be used for checking
   * @param {string|Function} callback The function to run when the condition is met.
   * If a string is provided it should be a valid jLight function name
   * @param {...*} [args] The arguments to supply to the given jLight function
   * @returns {jLight} jLight collection
   */
  when: (condition, callback, ...args) => {
    if (typeof condition === 'function' ? condition() : condition) {
      if (typeof callback === 'string') {
        jLight(elements)[callback](...args);
      } else {
        callback();
      }
    }

    return jLight(elements);
  },

  /**
   * Serializes the collections elements values to a URL encoded string.
   *
   * @function
   * @tutorial serialize
   * @returns {string} The resulting string
   */
  serialize: () => {
    let serializedString = '';

    elements.forEach((element, index) => {
      if (element instanceof HTMLFormElement) {
        serializedString += Array.from(new FormData(element),
          (formDataItem) => formDataItem.map(encodeURIComponent).join('=')).join('&amp;');
      } else if (canBeSeralized(element)) {
        let { value } = element;

        if (element.getAttribute('type') === 'checkbox') {
          value = element.checked;
        }

        serializedString += `${index === 0 ? '' : '&amp;'}${element.name}=${value}`;
      }
    });

    return serializedString;
  },

  /**
   * Serializes the collections elements values to a JSON object.
   *
   * @function
   * @tutorial serializeJson
   * @returns {Object.&lt;string, string>} The resulting JSON object
   */
  serializeJson: () => {
    let serializedJson = {};

    elements.forEach((element) => {
      if (element instanceof HTMLFormElement) {
        [...element.children].forEach((child) => {
          if (child.name) {
            serializedJson = addValueToJson(element, serializedJson);
          }
        });
      } else if (canBeSeralized(element)) {
        serializedJson = addValueToJson(element, serializedJson);
      }
    });

    return serializedJson;
  },
});

const documentAndWindowJLight = (argument) => ({
  ...argument,

  on: (eventNames, callbackOrSelector, delegatedCallbackOrOptions, options) => attachListener(
    documentAndWindowJLight,
    [argument],
    eventNames,
    callbackOrSelector,
    delegatedCallbackOrOptions,
    options,
    jLight,
  ),

  /* eslint-disable max-len */

  once: (eventNames, callbackOrSelector, delegatedCallbackOrOptions, options = {}) => attachListener(
    documentAndWindowJLight,
    [argument],
    eventNames,
    callbackOrSelector,
    delegatedCallbackOrOptions,
    {
      ...options,
      once: true,
    },
    jLight,
  ),

  /* eslint-enable max-len */

  off: (eventNames, callback) => removeListener(
    documentAndWindowJLight,
    [argument],
    eventNames,
    callback,
  ),

  trigger: (eventNames, jLightEventData) => triggerListener(
    documentAndWindowJLight,
    [argument],
    eventNames,
    jLightEventData,
  ),

  innerWidth: () => window.innerWidth,

  innerHeight: () => window.innerHeight,

  outerWidth: () => window.outerWidth,

  outerHeight: () => window.outerHeight,

  scrollTop: (value) => {
    if (value !== undefined) {
      window.scrollTo(0, value);

      return documentAndWindowJLight(argument);
    }

    return window.pageYOffset;
  },

  scrollLeft: (value) => {
    if (value !== undefined) {
      window.scrollTo(value, 0);

      return documentAndWindowJLight(argument);
    }

    return window.pageXOffset;
  },

  scrollTo: (theArgument, duration = 300, theOffset = {}, callback) => {
    const offset = {
      x: 0,
      y: 0,
      ...theOffset,
    };

    const elements = getElementsFromArgument(theArgument);
    const boundingBox = elements[0].getBoundingClientRect();
    const top = boundingBox.top + window.pageYOffset;
    const left = boundingBox.left + window.pageXOffset;
    const { innerWidth, innerHeight } = window;
    const { scrollWidth, scrollHeight } = document.body;
    const targetX = scrollWidth - left &lt; innerWidth
      ? scrollWidth - innerWidth - offset.x
      : left - offset.x;
    const targetY = scrollHeight - top &lt; innerHeight
      ? scrollHeight - innerHeight - offset.y
      : top - offset.y;
    const startPositionX = window.pageXOffset;
    const startPositionY = window.pageYOffset;
    const differenceX = targetX - startPositionX;
    const differenceY = targetY - startPositionY;

    doEasing(duration, (percent) => {
      window.scrollTo(
        startPositionX + differenceX * percent,
        startPositionY + differenceY * percent,
      );
    }, callback);

    return documentAndWindowJLight(argument);
  },
});

/**
 * @global
 * @function
 * @tutorial tut-constructor
 * @description jLights default export
 * @param {jLight|string|Function|HTMLElement|HTMLCollection|NodeList|document|window} argument
 * The argument to initialize jLight on
 * @property {function} noop [Go to definition]{@link module:Utility.noop}
 * @property {function} uniqid [Go to definition]{@link module:Utility.uniqid}
 * @property {function} generateHash [Go to definition]{@link module:Utility.generateHash}
 * @property {function} isEmptyObject [Go to definition]{@link module:Utility.isEmptyObject}
 * @property {function} isSameObject [Go to definition]{@link module:Utility.isSameObject}
 * @property {function} preventEvent [Go to definition]{@link module:Utility.preventEvent}
 * @property {function} doEasing [Go to definition]{@link module:Utility.doEasing}
 * @property {function} lcfirst [Go to definition]{@link module:String.lcfirst}
 * @property {function} ucfirst [Go to definition]{@link module:String.ucfirst}
 * @property {function} camelToKebab [Go to definition]{@link module:String.camelToKebab}
 * @property {function} camelToSnake [Go to definition]{@link module:String.camelToSnake}
 * @property {function} kebabToCamel [Go to definition]{@link module:String.kebabToCamel}
 * @property {function} kebabToSnake [Go to definition]{@link module:String.kebabToSnake}
 * @property {function} snakeToCamel [Go to definition]{@link module:String.snakeToCamel}
 * @property {function} snakeToKebab [Go to definition]{@link module:String.snakeToKebab}
 * @property {function} ajax [Go to definition]{@link module:Ajax.ajax}
 * @property {function} get [Go to definition]{@link module:Ajax.get}
 * @property {function} post [Go to definition]{@link module:Ajax.post}
 * @returns {jLight} jLight collection
 */
const $ = (argument) => {
  if (!argument) {
    return jLight([]);
  }

  if (argument.elements
    &amp;&amp; Array.isArray(argument.elements)
    &amp;&amp; argument.elements.every((element) => element instanceof HTMLElement)) {
    return jLight(argument.elements);
  }

  if (typeof argument === 'function') {
    if (document.readyState !== 'loading') {
      argument();
    } else {
      document.addEventListener('DOMContentLoaded', argument);
    }

    return documentAndWindowJLight(document);
  }

  if (argument === document || argument === window) {
    initalizeJLightElementData(argument, argument);

    return documentAndWindowJLight(argument);
  }

  if (argument instanceof HTMLElement) {
    return jLight([argument]);
  }

  if (argument instanceof NodeList
    || argument instanceof HTMLCollection) {
    return jLight([...argument]);
  }

  let elements = [];

  if (typeof argument === 'string') {
    if (argument.match(/&lt;(.|\n)+>/)) {
      elements = [...createElementsFromString(argument)];
    } else {
      try {
        elements = [...document.querySelectorAll(argument)];

        elements.forEach((element) => {
          initalizeJLightElementData(element, argument);
        });
      } catch (e) {
        return jLight([]);
      }
    }
  }

  return jLight(elements);
};

$.noop = noop;
$.uniqid = uniqid;
$.generateHash = generateHash;
$.isEmptyObject = isEmptyObject;
$.isSameObject = isSameObject;
$.preventEvent = preventEvent;
$.doEasing = doEasing;
$.lcfirst = lcfirst;
$.ucfirst = ucfirst;
$.camelToKebab = camelToKebab;
$.camelToSnake = camelToSnake;
$.kebabToCamel = kebabToCamel;
$.kebabToSnake = kebabToSnake;
$.snakeToCamel = snakeToCamel;
$.snakeToKebab = snakeToKebab;
$.ajax = ajax;
$.get = get;
$.post = post;

export default $;
</code></pre>
        </article>
    </section>




    </div>

    <footer class="footer" id="footer">
      
    </footer>

    <script src="scripts/third-party/prism.js"></script>
    <script type="text/javascript" src="scripts/misc.js"></script>
    <script type="text/javascript" src="scripts/line-number-rows.js"></script>
    <script src="scripts/fix-navbar.js"></script>
    
      <script src="scripts/search.js"></script>
      <script src="scripts/third-party/fuse.js"></script>
      <script>
        var list = [{"title":"Ajax","link":"<a href=\"module-Ajax.html\">Ajax</a>"},{"title":"module:Ajax.ajax","link":"<a href=\"module-Ajax.html#.ajax\">module:Ajax.ajax</a>"},{"title":"module:Ajax.get","link":"<a href=\"module-Ajax.html#.get\">module:Ajax.get</a>"},{"title":"module:Ajax.post","link":"<a href=\"module-Ajax.html#.post\">module:Ajax.post</a>"},{"title":"Animation","link":"<a href=\"module-Animation.html\">Animation</a>"},{"title":"module:Animation~animate","link":"<a href=\"module-Animation.html#~animate\">module:Animation~animate</a>"},{"title":"module:Animation~fadeIn","link":"<a href=\"module-Animation.html#~fadeIn\">module:Animation~fadeIn</a>"},{"title":"module:Animation~fadeOut","link":"<a href=\"module-Animation.html#~fadeOut\">module:Animation~fadeOut</a>"},{"title":"module:Animation~fadeToggle","link":"<a href=\"module-Animation.html#~fadeToggle\">module:Animation~fadeToggle</a>"},{"title":"module:Animation~scrollTo","link":"<a href=\"module-Animation.html#~scrollTo\">module:Animation~scrollTo</a>"},{"title":"module:Animation~slideDown","link":"<a href=\"module-Animation.html#~slideDown\">module:Animation~slideDown</a>"},{"title":"module:Animation~slideToggle","link":"<a href=\"module-Animation.html#~slideToggle\">module:Animation~slideToggle</a>"},{"title":"module:Animation~slideUp","link":"<a href=\"module-Animation.html#~slideUp\">module:Animation~slideUp</a>"},{"title":"module:Animation~stop","link":"<a href=\"module-Animation.html#~stop\">module:Animation~stop</a>"},{"title":"ArrayLike","link":"<a href=\"module-ArrayLike.html\">ArrayLike</a>"},{"title":"module:ArrayLike~concat","link":"<a href=\"module-ArrayLike.html#~concat\">module:ArrayLike~concat</a>"},{"title":"module:ArrayLike~each","link":"<a href=\"module-ArrayLike.html#~each\">module:ArrayLike~each</a>"},{"title":"module:ArrayLike~every","link":"<a href=\"module-ArrayLike.html#~every\">module:ArrayLike~every</a>"},{"title":"module:ArrayLike~filter","link":"<a href=\"module-ArrayLike.html#~filter\">module:ArrayLike~filter</a>"},{"title":"module:ArrayLike~find","link":"<a href=\"module-ArrayLike.html#~find\">module:ArrayLike~find</a>"},{"title":"module:ArrayLike~forEach","link":"<a href=\"module-ArrayLike.html#~forEach\">module:ArrayLike~forEach</a>"},{"title":"module:ArrayLike~includes","link":"<a href=\"module-ArrayLike.html#~includes\">module:ArrayLike~includes</a>"},{"title":"module:ArrayLike~indexOf","link":"<a href=\"module-ArrayLike.html#~indexOf\">module:ArrayLike~indexOf</a>"},{"title":"module:ArrayLike~lastIndexOf","link":"<a href=\"module-ArrayLike.html#~lastIndexOf\">module:ArrayLike~lastIndexOf</a>"},{"title":"module:ArrayLike~map","link":"<a href=\"module-ArrayLike.html#~map\">module:ArrayLike~map</a>"},{"title":"module:ArrayLike~pop","link":"<a href=\"module-ArrayLike.html#~pop\">module:ArrayLike~pop</a>"},{"title":"module:ArrayLike~push","link":"<a href=\"module-ArrayLike.html#~push\">module:ArrayLike~push</a>"},{"title":"module:ArrayLike~reduce","link":"<a href=\"module-ArrayLike.html#~reduce\">module:ArrayLike~reduce</a>"},{"title":"module:ArrayLike~reverse","link":"<a href=\"module-ArrayLike.html#~reverse\">module:ArrayLike~reverse</a>"},{"title":"module:ArrayLike~shift","link":"<a href=\"module-ArrayLike.html#~shift\">module:ArrayLike~shift</a>"},{"title":"module:ArrayLike~slice","link":"<a href=\"module-ArrayLike.html#~slice\">module:ArrayLike~slice</a>"},{"title":"module:ArrayLike~some","link":"<a href=\"module-ArrayLike.html#~some\">module:ArrayLike~some</a>"},{"title":"module:ArrayLike~sort","link":"<a href=\"module-ArrayLike.html#~sort\">module:ArrayLike~sort</a>"},{"title":"module:ArrayLike~splice","link":"<a href=\"module-ArrayLike.html#~splice\">module:ArrayLike~splice</a>"},{"title":"module:ArrayLike~unshift","link":"<a href=\"module-ArrayLike.html#~unshift\">module:ArrayLike~unshift</a>"},{"title":"CSS","link":"<a href=\"module-CSS.html\">CSS</a>"},{"title":"module:CSS~addClass","link":"<a href=\"module-CSS.html#~addClass\">module:CSS~addClass</a>"},{"title":"module:CSS~css","link":"<a href=\"module-CSS.html#~css\">module:CSS~css</a>"},{"title":"module:CSS~hasClass","link":"<a href=\"module-CSS.html#~hasClass\">module:CSS~hasClass</a>"},{"title":"module:CSS~hide","link":"<a href=\"module-CSS.html#~hide\">module:CSS~hide</a>"},{"title":"module:CSS~removeClass","link":"<a href=\"module-CSS.html#~removeClass\">module:CSS~removeClass</a>"},{"title":"module:CSS~show","link":"<a href=\"module-CSS.html#~show\">module:CSS~show</a>"},{"title":"module:CSS~toggle","link":"<a href=\"module-CSS.html#~toggle\">module:CSS~toggle</a>"},{"title":"module:CSS~toggleClass","link":"<a href=\"module-CSS.html#~toggleClass\">module:CSS~toggleClass</a>"},{"title":"Dimensions","link":"<a href=\"module-Dimensions.html\">Dimensions</a>"},{"title":"module:Dimensions~height","link":"<a href=\"module-Dimensions.html#~height\">module:Dimensions~height</a>"},{"title":"module:Dimensions~innerHeight","link":"<a href=\"module-Dimensions.html#~innerHeight\">module:Dimensions~innerHeight</a>"},{"title":"module:Dimensions~innerWidth","link":"<a href=\"module-Dimensions.html#~innerWidth\">module:Dimensions~innerWidth</a>"},{"title":"module:Dimensions~offset","link":"<a href=\"module-Dimensions.html#~offset\">module:Dimensions~offset</a>"},{"title":"module:Dimensions~outerHeight","link":"<a href=\"module-Dimensions.html#~outerHeight\">module:Dimensions~outerHeight</a>"},{"title":"module:Dimensions~outerWidth","link":"<a href=\"module-Dimensions.html#~outerWidth\">module:Dimensions~outerWidth</a>"},{"title":"module:Dimensions~scrollHeight","link":"<a href=\"module-Dimensions.html#~scrollHeight\">module:Dimensions~scrollHeight</a>"},{"title":"module:Dimensions~scrollLeft","link":"<a href=\"module-Dimensions.html#~scrollLeft\">module:Dimensions~scrollLeft</a>"},{"title":"module:Dimensions~scrollTop","link":"<a href=\"module-Dimensions.html#~scrollTop\">module:Dimensions~scrollTop</a>"},{"title":"module:Dimensions~scrollWidth","link":"<a href=\"module-Dimensions.html#~scrollWidth\">module:Dimensions~scrollWidth</a>"},{"title":"module:Dimensions~width","link":"<a href=\"module-Dimensions.html#~width\">module:Dimensions~width</a>"},{"title":"ElementData","link":"<a href=\"module-ElementData.html\">ElementData</a>"},{"title":"module:ElementData~attr","link":"<a href=\"module-ElementData.html#~attr\">module:ElementData~attr</a>"},{"title":"module:ElementData~data","link":"<a href=\"module-ElementData.html#~data\">module:ElementData~data</a>"},{"title":"module:ElementData~html","link":"<a href=\"module-ElementData.html#~html\">module:ElementData~html</a>"},{"title":"module:ElementData~prop","link":"<a href=\"module-ElementData.html#~prop\">module:ElementData~prop</a>"},{"title":"module:ElementData~removeAttr","link":"<a href=\"module-ElementData.html#~removeAttr\">module:ElementData~removeAttr</a>"},{"title":"module:ElementData~text","link":"<a href=\"module-ElementData.html#~text\">module:ElementData~text</a>"},{"title":"module:ElementData~val","link":"<a href=\"module-ElementData.html#~val\">module:ElementData~val</a>"},{"title":"Event","link":"<a href=\"module-Event.html\">Event</a>"},{"title":"module:Event~delegate","link":"<a href=\"module-Event.html#~delegate\">module:Event~delegate</a>"},{"title":"module:Event~off","link":"<a href=\"module-Event.html#~off\">module:Event~off</a>"},{"title":"module:Event~on","link":"<a href=\"module-Event.html#~on\">module:Event~on</a>"},{"title":"module:Event~once","link":"<a href=\"module-Event.html#~once\">module:Event~once</a>"},{"title":"module:Event~trigger","link":"<a href=\"module-Event.html#~trigger\">module:Event~trigger</a>"},{"title":"module:Event~undelegate","link":"<a href=\"module-Event.html#~undelegate\">module:Event~undelegate</a>"},{"title":"Manipulation","link":"<a href=\"module-Manipulation.html\">Manipulation</a>"},{"title":"module:Manipulation~add","link":"<a href=\"module-Manipulation.html#~add\">module:Manipulation~add</a>"},{"title":"module:Manipulation~after","link":"<a href=\"module-Manipulation.html#~after\">module:Manipulation~after</a>"},{"title":"module:Manipulation~append","link":"<a href=\"module-Manipulation.html#~append\">module:Manipulation~append</a>"},{"title":"module:Manipulation~appendTo","link":"<a href=\"module-Manipulation.html#~appendTo\">module:Manipulation~appendTo</a>"},{"title":"module:Manipulation~before","link":"<a href=\"module-Manipulation.html#~before\">module:Manipulation~before</a>"},{"title":"module:Manipulation~clone","link":"<a href=\"module-Manipulation.html#~clone\">module:Manipulation~clone</a>"},{"title":"module:Manipulation~empty","link":"<a href=\"module-Manipulation.html#~empty\">module:Manipulation~empty</a>"},{"title":"module:Manipulation~insertAfter","link":"<a href=\"module-Manipulation.html#~insertAfter\">module:Manipulation~insertAfter</a>"},{"title":"module:Manipulation~insertBefore","link":"<a href=\"module-Manipulation.html#~insertBefore\">module:Manipulation~insertBefore</a>"},{"title":"module:Manipulation~prepend","link":"<a href=\"module-Manipulation.html#~prepend\">module:Manipulation~prepend</a>"},{"title":"module:Manipulation~prependTo","link":"<a href=\"module-Manipulation.html#~prependTo\">module:Manipulation~prependTo</a>"},{"title":"module:Manipulation~remove","link":"<a href=\"module-Manipulation.html#~remove\">module:Manipulation~remove</a>"},{"title":"module:Manipulation~wrap","link":"<a href=\"module-Manipulation.html#~wrap\">module:Manipulation~wrap</a>"},{"title":"Properties","link":"<a href=\"module-Properties.html\">Properties</a>"},{"title":"Selection","link":"<a href=\"module-Selection.html\">Selection</a>"},{"title":"module:Selection~children","link":"<a href=\"module-Selection.html#~children\">module:Selection~children</a>"},{"title":"module:Selection~closest","link":"<a href=\"module-Selection.html#~closest\">module:Selection~closest</a>"},{"title":"module:Selection~eq","link":"<a href=\"module-Selection.html#~eq\">module:Selection~eq</a>"},{"title":"module:Selection~first","link":"<a href=\"module-Selection.html#~first\">module:Selection~first</a>"},{"title":"module:Selection~get","link":"<a href=\"module-Selection.html#~get\">module:Selection~get</a>"},{"title":"module:Selection~has","link":"<a href=\"module-Selection.html#~has\">module:Selection~has</a>"},{"title":"module:Selection~last","link":"<a href=\"module-Selection.html#~last\">module:Selection~last</a>"},{"title":"module:Selection~next","link":"<a href=\"module-Selection.html#~next\">module:Selection~next</a>"},{"title":"module:Selection~not","link":"<a href=\"module-Selection.html#~not\">module:Selection~not</a>"},{"title":"module:Selection~parent","link":"<a href=\"module-Selection.html#~parent\">module:Selection~parent</a>"},{"title":"module:Selection~parents","link":"<a href=\"module-Selection.html#~parents\">module:Selection~parents</a>"},{"title":"module:Selection~prev","link":"<a href=\"module-Selection.html#~prev\">module:Selection~prev</a>"},{"title":"module:Selection~siblings","link":"<a href=\"module-Selection.html#~siblings\">module:Selection~siblings</a>"},{"title":"String","link":"<a href=\"module-String.html\">String</a>"},{"title":"module:String.camelToKebab","link":"<a href=\"module-String.html#.camelToKebab\">module:String.camelToKebab</a>"},{"title":"module:String.camelToSnake","link":"<a href=\"module-String.html#.camelToSnake\">module:String.camelToSnake</a>"},{"title":"module:String.kebabToCamel","link":"<a href=\"module-String.html#.kebabToCamel\">module:String.kebabToCamel</a>"},{"title":"module:String.kebabToSnake","link":"<a href=\"module-String.html#.kebabToSnake\">module:String.kebabToSnake</a>"},{"title":"module:String.lcfirst","link":"<a href=\"module-String.html#.lcfirst\">module:String.lcfirst</a>"},{"title":"module:String.snakeToCamel","link":"<a href=\"module-String.html#.snakeToCamel\">module:String.snakeToCamel</a>"},{"title":"module:String.snakeToKebab","link":"<a href=\"module-String.html#.snakeToKebab\">module:String.snakeToKebab</a>"},{"title":"module:String.ucfirst","link":"<a href=\"module-String.html#.ucfirst\">module:String.ucfirst</a>"},{"title":"Utility","link":"<a href=\"module-Utility.html\">Utility</a>"},{"title":"module:Utility.doEasing","link":"<a href=\"module-Utility.html#.doEasing\">module:Utility.doEasing</a>"},{"title":"module:Utility.generateHash","link":"<a href=\"module-Utility.html#.generateHash\">module:Utility.generateHash</a>"},{"title":"module:Utility.isEmptyObject","link":"<a href=\"module-Utility.html#.isEmptyObject\">module:Utility.isEmptyObject</a>"},{"title":"module:Utility.isSameObject","link":"<a href=\"module-Utility.html#.isSameObject\">module:Utility.isSameObject</a>"},{"title":"module:Utility.noop","link":"<a href=\"module-Utility.html#.noop\">module:Utility.noop</a>"},{"title":"module:Utility.preventEvent","link":"<a href=\"module-Utility.html#.preventEvent\">module:Utility.preventEvent</a>"},{"title":"module:Utility.uniqid","link":"<a href=\"module-Utility.html#.uniqid\">module:Utility.uniqid</a>"},{"title":"module:Utility~contains","link":"<a href=\"module-Utility.html#~contains\">module:Utility~contains</a>"},{"title":"module:Utility~delay","link":"<a href=\"module-Utility.html#~delay\">module:Utility~delay</a>"},{"title":"module:Utility~inView","link":"<a href=\"module-Utility.html#~inView\">module:Utility~inView</a>"},{"title":"module:Utility~is","link":"<a href=\"module-Utility.html#~is\">module:Utility~is</a>"},{"title":"module:Utility~serialize","link":"<a href=\"module-Utility.html#~serialize\">module:Utility~serialize</a>"},{"title":"module:Utility~serializeJson","link":"<a href=\"module-Utility.html#~serializeJson\">module:Utility~serializeJson</a>"},{"title":"module:Utility~when","link":"<a href=\"module-Utility.html#~when\">module:Utility~when</a>"},{"title":"tut-ajax","link":"tut-ajax"},{"title":"tut-animation","link":"tut-animation"},{"title":"tut-array-like","link":"tut-array-like"},{"title":"tut-constructor","link":"tut-constructor"},{"title":"tut-css","link":"tut-css"},{"title":"tut-dimensions","link":"tut-dimensions"},{"title":"tut-element-data","link":"tut-element-data"},{"title":"tut-event","link":"tut-event"},{"title":"tut-manipulation","link":"tut-manipulation"},{"title":"tut-properties","link":"tut-properties"},{"title":"tut-selection","link":"tut-selection"},{"title":"tut-string","link":"tut-string"},{"title":"tut-utility","link":"tut-utility"},{"title":"$","link":"<a href=\"global.html#$\">$</a>"},{"title":"ajaxCompleteCallback","link":"<a href=\"global.html#ajaxCompleteCallback\">ajaxCompleteCallback</a>"},{"title":"animateCallback","link":"<a href=\"global.html#animateCallback\">animateCallback</a>"},{"title":"animateOutCallback","link":"<a href=\"global.html#animateOutCallback\">animateOutCallback</a>"},{"title":"arrayBooleanCallback","link":"<a href=\"global.html#arrayBooleanCallback\">arrayBooleanCallback</a>"},{"title":"arrayLengthCallback","link":"<a href=\"global.html#arrayLengthCallback\">arrayLengthCallback</a>"},{"title":"attrCallback","link":"<a href=\"global.html#attrCallback\">attrCallback</a>"},{"title":"cloneCallback","link":"<a href=\"global.html#cloneCallback\">cloneCallback</a>"},{"title":"compareCallback","link":"<a href=\"global.html#compareCallback\">compareCallback</a>"},{"title":"contentCallback","link":"<a href=\"global.html#contentCallback\">contentCallback</a>"},{"title":"cssCallback","link":"<a href=\"global.html#cssCallback\">cssCallback</a>"},{"title":"cssClassCallback","link":"<a href=\"global.html#cssClassCallback\">cssClassCallback</a>"},{"title":"dataCallback","link":"<a href=\"global.html#dataCallback\">dataCallback</a>"},{"title":"defaultCallback","link":"<a href=\"global.html#defaultCallback\">defaultCallback</a>"},{"title":"delayCallback","link":"<a href=\"global.html#delayCallback\">delayCallback</a>"},{"title":"delegateCallback","link":"<a href=\"global.html#delegateCallback\">delegateCallback</a>"},{"title":"dimensionCallback","link":"<a href=\"global.html#dimensionCallback\">dimensionCallback</a>"},{"title":"elementsBooleanCallback","link":"<a href=\"global.html#elementsBooleanCallback\">elementsBooleanCallback</a>"},{"title":"elementsCallback","link":"<a href=\"global.html#elementsCallback\">elementsCallback</a>"},{"title":"elementsNumberCallback","link":"<a href=\"global.html#elementsNumberCallback\">elementsNumberCallback</a>"},{"title":"eventCallback","link":"<a href=\"global.html#eventCallback\">eventCallback</a>"},{"title":"fadeCallback","link":"<a href=\"global.html#fadeCallback\">fadeCallback</a>"},{"title":"fadeToggleCallback","link":"<a href=\"global.html#fadeToggleCallback\">fadeToggleCallback</a>"},{"title":"filterCallback","link":"<a href=\"global.html#filterCallback\">filterCallback</a>"},{"title":"getOrSetValueCallback","link":"<a href=\"global.html#getOrSetValueCallback\">getOrSetValueCallback</a>"},{"title":"hasClassCallback","link":"<a href=\"global.html#hasClassCallback\">hasClassCallback</a>"},{"title":"indexElementCallback","link":"<a href=\"global.html#indexElementCallback\">indexElementCallback</a>"},{"title":"indexjLightCallback","link":"<a href=\"global.html#indexjLightCallback\">indexjLightCallback</a>"},{"title":"inViewCallback","link":"<a href=\"global.html#inViewCallback\">inViewCallback</a>"},{"title":"isCallback","link":"<a href=\"global.html#isCallback\">isCallback</a>"},{"title":"iteratorBooleanCallback","link":"<a href=\"global.html#iteratorBooleanCallback\">iteratorBooleanCallback</a>"},{"title":"iteratorCallback","link":"<a href=\"global.html#iteratorCallback\">iteratorCallback</a>"},{"title":"jLight","link":"<a href=\"global.html#jLight\">jLight</a>"},{"title":"mapCallback","link":"<a href=\"global.html#mapCallback\">mapCallback</a>"},{"title":"mapInnerCallback","link":"<a href=\"global.html#mapInnerCallback\">mapInnerCallback</a>"},{"title":"multipleElementsCallback","link":"<a href=\"global.html#multipleElementsCallback\">multipleElementsCallback</a>"},{"title":"offCallback","link":"<a href=\"global.html#offCallback\">offCallback</a>"},{"title":"offsetCallback","link":"<a href=\"global.html#offsetCallback\">offsetCallback</a>"},{"title":"onCallback","link":"<a href=\"global.html#onCallback\">onCallback</a>"},{"title":"onStepCallback","link":"<a href=\"global.html#onStepCallback\">onStepCallback</a>"},{"title":"outerDimensionCallback","link":"<a href=\"global.html#outerDimensionCallback\">outerDimensionCallback</a>"},{"title":"outerIteratorCallback","link":"<a href=\"global.html#outerIteratorCallback\">outerIteratorCallback</a>"},{"title":"propCallback","link":"<a href=\"global.html#propCallback\">propCallback</a>"},{"title":"reduceCallback","link":"<a href=\"global.html#reduceCallback\">reduceCallback</a>"},{"title":"reduceInnerCallback","link":"<a href=\"global.html#reduceInnerCallback\">reduceInnerCallback</a>"},{"title":"removeAttrCallback","link":"<a href=\"global.html#removeAttrCallback\">removeAttrCallback</a>"},{"title":"removeCallback","link":"<a href=\"global.html#removeCallback\">removeCallback</a>"},{"title":"scrollToCallback","link":"<a href=\"global.html#scrollToCallback\">scrollToCallback</a>"},{"title":"selectorCallback","link":"<a href=\"global.html#selectorCallback\">selectorCallback</a>"},{"title":"sliceCallback","link":"<a href=\"global.html#sliceCallback\">sliceCallback</a>"},{"title":"slideCallback","link":"<a href=\"global.html#slideCallback\">slideCallback</a>"},{"title":"slideToggleCallback","link":"<a href=\"global.html#slideToggleCallback\">slideToggleCallback</a>"},{"title":"sortCallback","link":"<a href=\"global.html#sortCallback\">sortCallback</a>"},{"title":"spliceCallback","link":"<a href=\"global.html#spliceCallback\">spliceCallback</a>"},{"title":"stringCallback","link":"<a href=\"global.html#stringCallback\">stringCallback</a>"},{"title":"stringObjectCallback","link":"<a href=\"global.html#stringObjectCallback\">stringObjectCallback</a>"},{"title":"toggleCssClassCallback","link":"<a href=\"global.html#toggleCssClassCallback\">toggleCssClassCallback</a>"},{"title":"toggleVisibilityCallback","link":"<a href=\"global.html#toggleVisibilityCallback\">toggleVisibilityCallback</a>"},{"title":"triggerCallback","link":"<a href=\"global.html#triggerCallback\">triggerCallback</a>"},{"title":"valCallback","link":"<a href=\"global.html#valCallback\">valCallback</a>"},{"title":"visibilityCallback","link":"<a href=\"global.html#visibilityCallback\">visibilityCallback</a>"},{"title":"whenCallback","link":"<a href=\"global.html#whenCallback\">whenCallback</a>"},{"title":"xhrCallback","link":"<a href=\"global.html#xhrCallback\">xhrCallback</a>"}];
        var options = 
          setupSearch(list, options)
      </script>
    

    

    

    

    
    <script type="text/javascript">
    var option = JSON.parse('true')
      document.addEventListener("DOMContentLoaded", function () {
        OverlayScrollbars(document.querySelectorAll('body'), option.option || {});
        OverlayScrollbars(document.querySelectorAll('.sidebar-main-content'), option.option || {});
      });
    </script>
    


  </body>

</html>